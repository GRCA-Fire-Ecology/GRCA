---
title: "Grand Canyon QAQC for RAP Data"
author: "Alexandra Lalor"
date: "2025-02-10"
output:
  html_document:
    theme: readable
    highlight: 
    toc: yes
    toc_depth: 3
    toc_float:
      smooth_scroll: yes
  pdf_document:
    toc: yes
    toc_depth: '3'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)

# Install packages (if needed)
# install.packages("tidyverse")
# install.packages("Rtools")
# install.packages("janitor")
# install.packages("condformat")
```

# BEFORE STARTING

### Load Packages

```{r}
# Load packages
library(tidyverse)
library(writexl)
library(dplyr)
library(janitor)
#detach(package:plyr)
library(knitr)
# EnvStats is needed for the rosnerTest() function
library(EnvStats)
# condformat is used to format excel output files
library(condformat)
```

### Adjust File Paths

Make sure to update file paths to be specific for your data.

```{r}
# Identify working directory (specifically user name)
getwd()

# Load in data. Change file path based on user name!

# North Rim
path_data_N <- "X:/FFI Data Management/Exports from FFI/GRCA_RAP/North Rim/2025-02-10/"
# South Rim
path_data_S <- "X:/FFI Data Management/Exports from FFI/GRCA_RAP/South Rim/2025-02-10/"
# Errors
path_errors <- "C:/Users/alalor.NPS/OneDrive - DOI/Desktop/R/GRCA/output/errors/"
path_errors_name <- "GRCA RAP QAQC Errors"
```

### Create Function

```{r}
# QAQC function
qaqc <- function(data, query, query_message, values_check) {
  
  # Check if there is data to QAQC
  if(nrow(data) == 0) {
  # If there is no data, default to "No Error" data frame
  errors <- errors_blank_NoError %>%     
      mutate(SavedQuery = query)
  # If there is data, perform error check
} else {
  
  # Use relevant dataset to look for errors
  errors <- data %>%  
    # Add columns relevant to error checking
           # Populate the "SavedQuery" column with the query name
    mutate("SavedQuery" = query, 
           # Populate the "Error" column with the query message and relevant data
           "Error" = paste(query_message, "=", values_data),
           # Create a blank "Fixed" column
           "Fixed" = "",
           # Create a blank "Explanation" column
           "Explanation" = "",
           # Create a blank "Queryers" column
           "Queryers" = "") %>%   
    # Filter for data which is "false" (data does not match valid conditions)
    # NA values are treated as "false" (missing data is not valid)
    filter(!(values_check %>% replace_na(FALSE))) %>%   
    # Select relevant columns to view errors
    select("SavedQuery","MacroPlot.Name","Date","Error", "Fixed", "Explanation", "Queryers")
  
  # Next, check if there are duplicate errors
  errors_temp <- errors %>% 
    get_dupes(SavedQuery,MacroPlot.Name, Date, Error)
  # Merge duplicate errors
  errors <- unique(merge(errors, errors_temp, all = T))
  # If duplicate errors exist, add number of duplicates to error message
  errors <- errors %>% 
    mutate(Error = ifelse(is.na(dupe_count), Error, paste0("(x", dupe_count, ") ", Error))) %>% 
    select(!"dupe_count")
}
  
  # Check if there are no errors
  if (nrow(errors) == 0) {  
    # If there are no errors, default to "No Error" data frame
    errors <- errors_blank_NoError %>%     
      mutate(SavedQuery = query) 
    # If there are errors, keep error log you just created
  } else {   
    errors <- errors
  }
}
```

```{r}
# Blank data frame for no errors
errors_blank_NoError <- data.frame("SavedQuery" = "","MacroPlot.Name" = "","Date" = "","Error" = "No Error", "Fixed" = "", "Explanation" = "", "Queryers" = "")
# Blank data frame
errors_blank <- data.frame("SavedQuery" = "","MacroPlot.Name" = "","Date" = "","Error" = "", "Fixed" = "", "Explanation" = "", "Queryers" = "")
```

### Load Data

North Rim

```{r}
# Load in data
Fuels1000_all_N <- read.csv(paste0(path_data_N, "Surface Fuels - 1000Hr_XPT.csv"))
FuelsDuffLitt_all_N <- read.csv(paste0(path_data_N, "Surface Fuels - Duff_Litter_XPT.csv"))
FuelsFine_all_N <- read.csv(paste0(path_data_N, "Surface Fuels - Fine_XPT.csv"))
PostBurn_all_N <- read.csv(paste0(path_data_N, "Post Burn Severity_XPT.csv"))
Trees_all_N <- read.csv(paste0(path_data_N, "Trees - Individuals (metric)_XPT.csv"))
Seedlings_all_N <- read.csv(paste0(path_data_N, "Density - Quadrats (metric)_XPT.csv"), quote = "")
HerbsObs_all_N <- read.csv(paste0(path_data_N, "Cover - Species Composition (metric)_XPT.csv"), quote = "")
```

South Rim

```{r}
# Load in data
Fuels1000_all_S <- read.csv(paste0(path_data_S, "Surface Fuels - 1000Hr_XPT.csv"))
FuelsDuffLitt_all_S <- read.csv(paste0(path_data_S, "Surface Fuels - Duff_Litter_XPT.csv"))
FuelsFine_all_S <- read.csv(paste0(path_data_S, "Surface Fuels - Fine_XPT.csv"))
PostBurn_all_S <- read.csv(paste0(path_data_S, "Post Burn Severity_XPT.csv"))
Trees_all_S <- read.csv(paste0(path_data_S, "Trees - Individuals (metric)_XPT.csv"))
Seedlings_all_S <- read.csv(paste0(path_data_S, "Density - Quadrats (metric)_XPT.csv"), quote = "")
HerbsObs_all_S <- read.csv(paste0(path_data_S, "Cover - Species Composition (metric)_XPT.csv"), quote = "")
```

### Merge Data

```{r}
# Merge M and P
Fuels1000_all <- rbind(Fuels1000_all_N, Fuels1000_all_S)
FuelsDuffLitt_all <- rbind(FuelsDuffLitt_all_N, FuelsDuffLitt_all_S)
FuelsFine_all <- rbind(FuelsFine_all_N, FuelsFine_all_S)
PostBurn_all <- rbind(PostBurn_all_N, PostBurn_all_S)
Trees_all <- rbind(Trees_all_N, Trees_all_S)
Seedlings_all <- rbind(Seedlings_all_N, Seedlings_all_S)
HerbsObs_all <- rbind(HerbsObs_all_N, HerbsObs_all_S)
```

```{r}
# Remove extra data
remove(Fuels1000_all_N, Fuels1000_all_S, FuelsDuffLitt_all_N, FuelsDuffLitt_all_S, FuelsFine_all_N, FuelsFine_all_S, PostBurn_all_N, PostBurn_all_S, Trees_all_N, Trees_all_S, Seedlings_all_N, Seedlings_all_S, HerbsObs_all_N, HerbsObs_all_S)
```

### Clean & Filter Data

Fuels1000

```{r}
# Clean up data frame
Fuels1000_all <- Fuels1000_all %>%
  # Separate Date column into Date and Time columns
  separate(Date, sep = " ", into = c("Date", "Time")) %>%
  separate(Date, sep = "/", into = c("Month", "Day", "Year"), remove = FALSE) %>%
  select(!c("Month", "Day", "Time"))

# Ensure blanks in Visited column are NA
Fuels1000_all$Visited[Fuels1000_all$Visited==""] <- NA

# Filter for only data
Fuels1000_data <- Fuels1000_all %>%
  filter(is.na(Visited))

# Filter for only headers
Fuels1000_header <- Fuels1000_all %>%
  filter(!is.na(Visited))
```

FuelsDuffLitt

```{r}
# Clean up data frame 
FuelsDuffLitt_all <- FuelsDuffLitt_all %>%  
  # Separate Date column into Date and Time columns   
  separate(Date, sep = " ", into = c("Date", "Time")) %>% 
  separate(Date, sep = "/", into = c("Month", "Day", "Year"), remove = FALSE) %>%
  select(!c("Month", "Day", "Time"))

# Ensure blanks in Visited column are NA 
FuelsDuffLitt_all$Visited[FuelsDuffLitt_all$Visited==""] <- NA 

# Filter for only data 
FuelsDuffLitt_data <- FuelsDuffLitt_all %>%   
  filter(is.na(Visited))  

# Filter for only headers 
FuelsDuffLitt_header <- FuelsDuffLitt_all %>%   
  filter(!is.na(Visited))
```

FuelsFine

```{r}
# Clean up data frame 
FuelsFine_all <- FuelsFine_all %>%
  # Separate Date column into Date and Time columns   
  separate(Date, sep = " ", into = c("Date", "Time")) %>%   
  separate(Date, sep = "/", into = c("Month", "Day", "Year"), remove = FALSE) %>%
  select(!c("Month", "Day", "Time"))

# Ensure blanks in Visited column are NA 
FuelsFine_all$Visited[FuelsFine_all$Visited==""] <- NA  

# Filter for only data 
FuelsFine_data <- FuelsFine_all %>%   
  filter(is.na(Visited))  

# Filter for only headers 
FuelsFine_header <- FuelsFine_all %>%   
  filter(!is.na(Visited))
```

PostBurn

```{r}
# Clean up data frame
PostBurn_all <- PostBurn_all %>%
  # Separate Date column into Date and Time columns
  separate(Date, sep = " ", into = c("Date", "Time")) %>%
  separate(Date, sep = "/", into = c("Month", "Day", "Year"), remove = FALSE) %>%
  select(!c("Month", "Day", "Time"))

# Ensure blanks in Visited column are NA
PostBurn_all$Visited[PostBurn_all$Visited==""] <- NA

# Filter for only data
PostBurn_data <- PostBurn_all %>%
  filter(is.na(Visited))

# Filter for only headers
PostBurn_header <- PostBurn_all %>%
  filter(!is.na(Visited))
```

Trees

```{r}
# Clean up data frame 
Trees_all <- Trees_all %>%
  # Separate Date column into Date and Time columns   
  separate(Date, sep = " ", into = c("Date", "Time")) %>%   
  separate(Date, sep = "/", into = c("Month", "Day", "Year"), remove = FALSE) %>%
  select(!c("Month", "Day", "Time"))

# Ensure blanks in Visited column are NA 
Trees_all$Visited[Trees_all$Visited==""] <- NA  

# Filter for only data 
Trees_data <- Trees_all %>%   
  filter(is.na(Visited))  

# Filter for only headers 
Trees_header <- Trees_all %>%   
  filter(!is.na(Visited))
```

Seedlings

```{r}
# Clean up data frame 
Seedlings_all <- Seedlings_all %>%
  # Separate Date column into Date and Time columns   
  separate(Date, sep = " ", into = c("Date", "Time")) %>%   
  separate(Date, sep = "/", into = c("Month", "Day", "Year"), remove = FALSE) %>%
  select(!c("Month", "Day", "Time"))

# Ensure blanks in Visited column are NA 
Seedlings_all$Visited[Seedlings_all$Visited==""] <- NA 

# Filter for only data 
Seedlings_data <- Seedlings_all %>%   
  filter(is.na(Visited))  

# Filter for only headers 
Seedlings_header <- Seedlings_all %>%   
  filter(!is.na(Visited))
```

HerbsObs

```{r}
# Clean up data frame 
HerbsObs_all <- HerbsObs_all %>%  
  # Separate Date column into Date and Time columns   
  separate(Date, sep = " ", into = c("Date", "Time")) %>%   
  separate(Date, sep = "/", into = c("Month", "Day", "Year"), remove = FALSE) %>%
  select(!c("Month", "Day", "Time"))

# Ensure blanks in Visited column are NA 
HerbsObs_all$Visited[HerbsObs_all$Visited==""] <- NA  

# Filter for only data 
HerbsObs_data <- HerbsObs_all %>%   
  filter(is.na(Visited))  

# Filter for only headers 
HerbsObs_header <- HerbsObs_all %>%   
  filter(!is.na(Visited))
```

# PROTOCOL - SURFACE FUELS

## 1000HR (CWD)

This code conducts quality control checks on coarse woody debris (CWD) surface fuels data within the "Surface Fuels - 1000Hr" data set.

It checks for errors in: headers, decay class values, fuel constants, duplicates, transect numbers, slope, and diameter.

### Fuel 1000 Header

[Problem:]{.underline} Incorrect header information entered for RAP plots.

[Procedure:]{.underline}

-   Check that NumTran = 1 for the appropriate project units: Moqui, Picnic, Quarry

```{r}
# Set parameters 
data <- Fuels1000_header %>% 
  filter(MacroPlot.Purpose %in% c("Moqui", "Picnic", "Quarry"))
query <- "Fuel 1000 Header NumTran"
query_message <- "Number of Transects" 
values_data <- data$NumTran
values_valid <- 1
values_check <- values_data == values_valid

# Identify errors
errors_Fuels1000_NumTran_1 <- qaqc(data, query, query_message, values_check)
```

-   Check that NumTran = 2 for the appropriate project units: Burnt Corral, Fawn Spring, Hwy 67, Range, Spring Canyon, Thompson, Tipover, Tusayan Pueblo (Thinning)

```{r}
# Set parameters 
data <- Fuels1000_header %>% 
  filter(MacroPlot.Purpose %in% c("Burnt Corral", "Fawn Spring", "Hwy 67", "Range", "Spring Canyon", "Thompson", "Tipover", "Tusayan Pueblo (Thinning)"))
query <- "Fuel 1000 Header NumTran"
query_message <- "Number of Transects" 
values_data <- data$NumTran
values_valid <- 2
values_check <- values_data == values_valid

# Identify errors
errors_Fuels1000_NumTran_2 <- qaqc(data, query, query_message, values_check)
```

-   Check that TranLen = 50

```{r}
# Set parameters 
data <- Fuels1000_header
query <- "Fuel 1000 Header TranLen" 
query_message <- "Transect Length" 
values_data <- data$TranLen 
values_valid <- 50  
values_check <-values_data == values_valid

# Identify errors
errors_Fuels1000_TranLen <- qaqc(data, query, query_message, values_check)
```

#### Combine Header Errors

```{r}
# Combine
errors_Fuels1000_Header <- unique(rbind(errors_Fuels1000_NumTran_1, errors_Fuels1000_NumTran_2, errors_Fuels1000_TranLen))

remove(errors_Fuels1000_NumTran_1, errors_Fuels1000_NumTran_2, errors_Fuels1000_TranLen)
```

### Fuel 1000 Hits

[Problem:]{.underline} Extra or missing data points in FMH plots. Plots with no course woody debris should be verified.

[Procedure:]{.underline}

-   Group by Macroplot and Date. Calculate number of hits per plot. Check that sum_hits \> 0

```{r}
# Filter NA values. Add number of hits and store in new column
data_temp1 <- Fuels1000_data %>%
  group_by(MacroPlot.Name, Date) %>% 
  dplyr::summarize("sum_hits" = n())

data_temp2 <- Fuels1000_header %>% 
  group_by(MacroPlot.Name, Date) %>% 
  dplyr::summarise()

data_temp <- merge(data_temp1, data_temp2, by = c("MacroPlot.Name","Date"), all = TRUE)
data_temp$sum_hits[is.na(data_temp$sum_hits)] <- 0
remove(data_temp1, data_temp2)

# Set parameters 
data <- merge(Fuels1000_data, data_temp, by = c("MacroPlot.Name", "Date"), all = T)
query <- "Fuel 1000 Hits" 
query_message <- "CWD" 
values_data <- data$sum_hits
values_valid <- 0
values_check <- values_data > values_valid

# Identify errors
errors_Fuels1000_Hits <- qaqc(data, query, query_message, values_check)
```

### Fuel 1000 DecayClass

[Problem:]{.underline} Logs have an entry for decay class that we don’t use.

[Procedure:]{.underline}

-   Check that DecayCl = 3 or 4

```{r}
# Set parameters
data <- Fuels1000_data
query <- "Fuel 1000 DecayClass"
query_message <- paste0("Log ", data$LogNum, ". ", "Decay Class")
values_data <- data$DecayCl
values_valid <- c(3,4)
values_check <- values_data %in% values_valid

# Identify errors
errors_Fuels1000_DecayCl <- qaqc(data, query, query_message, values_check)
```

### Fuel 1000 FuelConst

[Problem:]{.underline} Incorrect coarse woody debris fuel constant entered.

[Procedure:]{.underline}

-   Check that CWDFuConSt = Mixed Conifer for the appropriate project units: Fawn Spring, Hwy 67, Range, Spring Canyon, Thompson, Tipover

```{r}
# Set parameters
data <- Fuels1000_data %>% 
  filter(MacroPlot.Purpose %in% c("Fawn Spring", "Hwy 67", "Range", "Spring Canyon", "Thompson", "Tipover"))
query <- "Fuel 1000 FuelConst"
query_message <- "Fuel Constant"
values_data <- data$CWDFuConSt
values_valid <- "Mixed Conifer"
values_check <- values_data == values_valid

# Identify errors
errors_Fuels1000_FuelConst_MixCon <- qaqc(data, query, query_message, values_check)
```

-   Check that CWDFuConSt = PIPO for the appropriate project units: Burnt Corral, Moqui, Picnic, Quarry

```{r}
# Set parameters
data <- Fuels1000_data %>% 
  filter(MacroPlot.Purpose %in% c("Burnt Corral", "Moqui", "Picnic", "Quarry"))
query <- "Fuel 1000 FuelConst"
query_message <- "Fuel Constant"
values_data <- data$CWDFuConSt
values_valid <- "PIPO"
values_check <- values_data == values_valid

# Identify errors
errors_Fuels1000_FuelConst_PIPO <- qaqc(data, query, query_message, values_check)
```

-   Check that CWDFuConSt = PIED for the appropriate project units: Tusayan Pueblo (Thinning)

```{r}
# Set parameters
data <- Fuels1000_data %>% 
  filter(MacroPlot.Purpose %in% c("Tusayan Pueblo (Thinning)"))
query <- "Fuel 1000 FuelConst"
query_message <- "Fuel Constant"
values_data <- data$CWDFuConSt
values_valid <- "PIED"
values_check <- values_data == values_valid

# Identify errors
errors_Fuels1000_FuelConst_PIED <- qaqc(data, query, query_message, values_check)
```

#### Combine FuelConst Errors

```{r}
# Combine
errors_Fuels1000_FuelConst <- unique(rbind(errors_Fuels1000_FuelConst_MixCon, errors_Fuels1000_FuelConst_PIPO, errors_Fuels1000_FuelConst_PIED))

remove(errors_Fuels1000_FuelConst_MixCon, errors_Fuels1000_FuelConst_PIPO, errors_Fuels1000_FuelConst_PIED)
```

### Fuel 1000 LogNo

[Problem:]{.underline} "Duplicate" data exists due to multiple 1000 hr fuels with the same transect / diameter / decay class. Log Numbers are missing (which would differentiate 1000 hr fuels).

[Procedure:]{.underline}

-   Check for duplicate logs across Date, MacroPlot.Name, Transect, LogNum, Dia [and]{.underline} DecayCl.

```{r}
# Check for log duplication and store results in new column
data_temp <- Fuels1000_data %>%
  get_dupes(Date, MacroPlot.Name, Transect, LogNum, Dia, DecayCl)

# Set parameters 
data <- merge(Fuels1000_data, data_temp, all.x = T)
data$dupe_count[is.na(data$dupe_count)] <- 0
query <- "Fuel 1000 LogNo" 
query_message <- paste0("Log ", data$LogNum, ". ", "Transect ", data$Transect, ". ",  "Dia ", data$Dia, ". ",  "DecayCl ", data$DecayCl, ". ", "Duplicates")
values_data <- data$dupe_count
values_valid <- 0
values_check <- values_data == values_valid

# Identify errors
errors_Fuels1000_LogNo <- qaqc(data, query, query_message, values_check)
```

### Fuel 1000 Values

[Problem:]{.underline}  Values for transect, slope, and diameter are missing or unreasonable.

[Procedure:]{.underline}

-   Check that Transect = 1 for the appropriate project units: Moqui, Picnic, Quarry

```{r}
# Set parameters
data <- Fuels1000_data %>% 
  filter(MacroPlot.Purpose %in% c("Moqui", "Picnic", "Quarry"))
query <- "Fuel 1000 Values TransNum"
query_message <- "Transect Number"
values_data <- data$Transect
values_valid <- c(1)
values_check <- values_data %in% values_valid

# Identify errors
errors_Fuels1000_TransNum_1 <- qaqc(data, query, query_message, values_check)
```

-   Check that Transect = 1 or 2 for the appropriate project units: Burnt Corral, Fawn Spring, Hwy 67, Range, Spring Canyon, Thompson, Tipover, Tusayan Pueblo (Thinning)

```{r}
# Set parameters
data <- Fuels1000_data %>% 
  filter(MacroPlot.Purpose %in% c("Burnt Corral", "Fawn Spring", "Hwy 67", "Range", "Spring Canyon", "Thompson", "Tipover", "Tusayan Pueblo (Thinning)"))
query <- "Fuel 1000 Values TransNum"
query_message <- "Transect Number"
values_data <- data$Transect
values_valid <- c(1, 2)
values_check <- values_data %in% values_valid

# Identify errors
errors_Fuels1000_TransNum_2 <- qaqc(data, query, query_message, values_check)
```

-   Check that Slope values are reasonable.

```{r}
# Set parameters
data <- Fuels1000_data
query <- "Fuel 1000 Values Slope"
query_message <- paste0("Transect = ", data$Transect, ". ", "Slope")
values_data <- data$Slope
values_valid <- seq(0, 40, by = 1)
values_check <- values_data %in% values_valid

# Identify errors
errors_Fuels1000_Slope <- qaqc(data, query, query_message, values_check)
```

-   Check that diameter values are reasonable, are measured at 0.5 increments, and ≥ 3.0.

```{r}
# Perform Rosner's Test for outliers using all values
data_temp <- Fuels1000_all %>%
  filter(!is.na(Dia))
data_outlier <- rosnerTest(data_temp$Dia)
outliers <- data_outlier$all.stats$Value[data_outlier$all.stats$Outlier]
max_Dia <- ifelse(length(outliers) == 0, max(data_temp$Dia), min(outliers) - 1)

# Set parameters
data <- Fuels1000_data
query <- "Fuel 1000 Values Dia"
query_message <- paste0("Log ", data$LogNum, ". ", "Diameter")
values_data <- data$Dia
values_valid <- seq(3, max_Dia, by = 0.5)
values_check <- values_data %in% values_valid

# Identify errors
errors_Fuels1000_Dia <- qaqc(data, query, query_message, values_check)
```

#### Combine Values Errors

```{r}
# Combine
errors_Fuels1000_Values <- unique(rbind(errors_Fuels1000_TransNum_1, errors_Fuels1000_TransNum_2, errors_Fuels1000_Slope, errors_Fuels1000_Dia))

remove(errors_Fuels1000_TransNum_1, errors_Fuels1000_TransNum_2, errors_Fuels1000_Slope, errors_Fuels1000_Dia)
```

### Fuel 1000 Errors

```{r}
# errors_Fuels1000 <- unique(rbind(errors_Fuels1000_DecayCl, errors_Fuels1000_FuelConst, errors_Fuels1000_Header, errors_Fuels1000_Hits, errors_Fuels1000_LogNo, errors_Fuels1000_Values))

errors_Fuels1000 <- rbind(errors_Fuels1000_DecayCl, errors_blank, errors_Fuels1000_FuelConst, errors_blank, errors_Fuels1000_Header, errors_blank, errors_Fuels1000_Hits, errors_blank, errors_Fuels1000_LogNo, errors_blank, errors_Fuels1000_Values)

remove(errors_Fuels1000_DecayCl, errors_Fuels1000_FuelConst, errors_Fuels1000_Header, errors_Fuels1000_Hits, errors_Fuels1000_LogNo, errors_Fuels1000_Values)
```

```{r}
# Table of results for quick check
#kable(errors_Fuels1000, "pipe")

# Save as CSV or XLSX
path_errors
#write.csv(errors_Fuels1000, paste0(path_errors, "errors_GRCA_RAP_Fuels1000.csv"), quote=FALSE, row.names = FALSE, na = "")
#write_xlsx(errors_Fuels1000, paste0(path_errors, "errors_GRCA_RAP_Fuels1000.xlsx"))
```

## DUFF LITTER (DL)

This code conducts quality control checks on duff litter (DL) surface fuels data within the "Surface Fuels - Duff_Litter" data set.

It checks for errors in: headers, fuel constants, number of points sampled, litter values, and duff values.

### Fuel DL Header

[Problem:]{.underline} Incorrect header information entered for RAP plots.

[Procedure:]{.underline}

-   Check that NumTran = 1 for the appropriate project units: Moqui, Picnic, Quarry

```{r}
# Set parameters  
data <- FuelsDuffLitt_header %>% 
  filter(MacroPlot.Purpose %in% c("Moqui", "Picnic", "Quarry"))
query <- "Fuel DL Header NumTran" 
query_message <- "Number of Transects"  
values_data <- data$NumTran  
values_valid <- 1   
values_check <- values_data == values_valid

# Identify errors
errors_FuelsDuffLitt_NumTran_1 <- qaqc(data, query, query_message, values_check)
```

-   Check that NumTran = 2 for the appropriate project units: Burnt Corral, Fawn Spring, Hwy 67, Range, Spring Canyon, Thompson, Tipover, Tusayan Pueblo (Thinning)

```{r}
# Set parameters  
data <- FuelsDuffLitt_header %>% 
  filter(MacroPlot.Purpose %in% c("Burnt Corral", "Fawn Spring", "Hwy 67", "Range", "Spring Canyon", "Thompson", "Tipover", "Tusayan Pueblo (Thinning)"))
query <- "Fuel DL Header NumTran" 
query_message <- "Number of Transects"  
values_data <- data$NumTran  
values_valid <- 2 
values_check <- values_data == values_valid

# Identify errors
errors_FuelsDuffLitt_NumTran_2 <- qaqc(data, query, query_message, values_check)
```

#### Combine Header Errors

```{r}
# Combine
errors_FuelsDuffLitt_Header <- unique(rbind(errors_FuelsDuffLitt_NumTran_1, errors_FuelsDuffLitt_NumTran_2))

remove(errors_FuelsDuffLitt_NumTran_1, errors_FuelsDuffLitt_NumTran_2)
```

### Fuel DL FuelConst

[Problem:]{.underline} Incorrect duff & litter fuel constant entered.

[Procedure:]{.underline}

-   Check that DLFuConSt = Mixed Conifer for the appropriate project units: Fawn Spring, Hwy 67, Range, Spring Canyon, Thompson, Tipover

```{r}
# Set parameters 
data <- FuelsDuffLitt_data %>% 
  filter(MacroPlot.Purpose %in% c("Fawn Spring", "Hwy 67", "Range", "Spring Canyon", "Thompson", "Tipover"))
query <- "Fuel DL FuelConst" 
query_message <- "Fuel Constant" 
values_data <- data$DLFuConSt 
values_valid <- "Mixed Conifer"
values_check <- values_data == values_valid

# Identify errors
errors_FuelsDuffLitt_FuelConst_MixCon <- qaqc(data, query, query_message, values_check)
```

-   Check that DLFuConSt = PIPO for the appropriate project units: Burnt Corral, Moqui, Picnic, Quarry

```{r}
# Set parameters 
data <- FuelsDuffLitt_data %>% 
  filter(MacroPlot.Purpose %in% c("Burnt Corral", "Moqui", "Picnic", "Quarry"))
query <- "Fuel DL FuelConst" 
query_message <- "Fuel Constant" 
values_data <- data$DLFuConSt 
values_valid <- "PIPO"
values_check <- values_data == values_valid

# Identify errors
errors_FuelsDuffLitt_FuelConst_PIPO <- qaqc(data, query, query_message, values_check)
```

-   Check that DLFuConSt = PIED for the appropriate project units: Tusayan Pueblo (Thinning)

```{r}
# Set parameters 
data <- FuelsDuffLitt_data %>% 
  filter(MacroPlot.Purpose %in% c("Tusayan Pueblo (Thinning)"))
query <- "Fuel DL FuelConst" 
query_message <- "Fuel Constant" 
values_data <- data$DLFuConSt 
values_valid <- "PIED"
values_check <- values_data == values_valid

# Identify errors
errors_FuelsDuffLitt_FuelConst_PIED <- qaqc(data, query, query_message, values_check)
```

#### Combine FuelConst Errors

```{r}
# Combine
errors_FuelsDuffLitt_FuelConst <- unique(rbind(errors_FuelsDuffLitt_FuelConst_MixCon, errors_FuelsDuffLitt_FuelConst_PIPO, errors_FuelsDuffLitt_FuelConst_PIED))

remove(errors_FuelsDuffLitt_FuelConst_MixCon, errors_FuelsDuffLitt_FuelConst_PIPO, errors_FuelsDuffLitt_FuelConst_PIED)
```

### Fuel DL Hits

[Problem:]{.underline} Extra or missing data points in RAP plots. There should be 1 or 2 transects with 10 sample points per transect. 

[Procedure:]{.underline}

-   1 transect project units: Moqui, Picnic, Quarry
-   Group by Macroplot and Date. Calculate number of hits per plot. Check that sum_hits = 10

```{r}
# Filter NA values. Add number of hits and store in new column
data_temp1 <- FuelsDuffLitt_data %>%
  filter(!is.na(LittDep)) %>%
  filter(!is.na(DuffDep)) %>% 
  group_by(MacroPlot.Name, Date) %>% 
  dplyr::summarise("sum_hits" = n())

data_temp2 <- FuelsDuffLitt_header %>% 
  group_by(MacroPlot.Name, Date) %>% 
  dplyr::summarise()

data_temp <- merge(data_temp1, data_temp2, by = c("MacroPlot.Name","Date"), all = TRUE)
data_temp$sum_hits[is.na(data_temp$sum_hits)] <- 0
remove(data_temp1, data_temp2)

# Set parameters 
data <- merge(FuelsDuffLitt_data, data_temp, by = c("MacroPlot.Name", "Date"), all = T) %>% 
  filter(MacroPlot.Purpose %in% c("Moqui", "Picnic", "Quarry"))
query <- "Fuel DL Hits" 
query_message <- "Complete Sample Locations"
values_data <- data$sum_hits
values_valid <- 10
values_check <- values_data == values_valid

# Identify errors
errors_FuelsDuffLitt_Hits_10 <- qaqc(data, query, query_message, values_check)
```

-   2 transect project units: Burnt Corral, Fawn Spring, Hwy 67, Range, Spring Canyon, Thompson, Tipover, Tusayan Pueblo (Thinning)
-   Group by Macroplot and Date. Calculate number of hits per plot. Check that sum_hits = 20

```{r}
# Filter NA values. Add number of hits and store in new column
data_temp1 <- FuelsDuffLitt_data %>%
  filter(!is.na(LittDep)) %>%
  filter(!is.na(DuffDep)) %>% 
  group_by(MacroPlot.Name, Date) %>% 
  dplyr::summarise("sum_hits" = n())

data_temp2 <- FuelsDuffLitt_header %>% 
  group_by(MacroPlot.Name, Date) %>% 
  dplyr::summarise()

data_temp <- merge(data_temp1, data_temp2, by = c("MacroPlot.Name","Date"), all = TRUE)
data_temp$sum_hits[is.na(data_temp$sum_hits)] <- 0
remove(data_temp1, data_temp2)

# Set parameters 
data <- merge(FuelsDuffLitt_data, data_temp, by = c("MacroPlot.Name", "Date"), all = T) %>% 
  filter(MacroPlot.Purpose %in% c("Burnt Corral", "Fawn Spring", "Hwy 67", "Range", "Spring Canyon", "Thompson", "Tipover", "Tusayan Pueblo (Thinning)"))
query <- "Fuel DL Hits" 
query_message <- "Complete Sample Locations"
values_data <- data$sum_hits
values_valid <- 20
values_check <- values_data == values_valid

# Identify errors
errors_FuelsDuffLitt_Hits_20 <- qaqc(data, query, query_message, values_check)
```

#### Combine Hits Errors

```{r}
# Combine
errors_FuelsDuffLitt_Hits <- unique(rbind(errors_FuelsDuffLitt_Hits_10, errors_FuelsDuffLitt_Hits_20))

remove(errors_FuelsDuffLitt_Hits_10, errors_FuelsDuffLitt_Hits_20)
```

### Fuel DL Values

[Problem:]{.underline}  Values for transect, litter, and duff depth are missing or unreasonable.

[Procedure:]{.underline}

-   Check that Transect = 1 for the appropriate project units: Moqui, Picnic, Quarry

```{r}
# Set parameters
data <- FuelsDuffLitt_data %>% 
  filter(MacroPlot.Purpose %in% c("Moqui", "Picnic", "Quarry"))
query <- "Fuel DL Values TransNum"
query_message <- "Transect Number"
values_data <- data$Transect
values_valid <- c(1)
values_check <- values_data %in% values_valid

# Identify errors
errors_FuelsDuffLitt_TransNum_1 <- qaqc(data, query, query_message, values_check)
```

-   Check that Transect = 1 or 2 for the appropriate project units: Burnt Corral, Fawn Spring, Hwy 67, Range, Spring Canyon, Thompson, Tipover, Tusayan Pueblo (Thinning)

```{r}
# Set parameters
data <- FuelsDuffLitt_data %>% 
  filter(MacroPlot.Purpose %in% c("Burnt Corral", "Fawn Spring", "Hwy 67", "Range", "Spring Canyon", "Thompson", "Tipover", "Tusayan Pueblo (Thinning)"))
query <- "Fuel DL Values TransNum"
query_message <- "Transect Number"
values_data <- data$Transect
values_valid <- c(1, 2)
values_check <- values_data %in% values_valid

# Identify errors
errors_FuelsDuffLitt_TransNum_2 <- qaqc(data, query, query_message, values_check)
```

-   Sort by LittDep. Check that litter depth values are reasonable.

```{r}
# Perform Rosner's Test for outliers using all values
data_temp <- FuelsDuffLitt_all %>%
  filter(!is.na(LittDep))
data_outlier <- rosnerTest(data_temp$LittDep)
outliers <- data_outlier$all.stats$Value[data_outlier$all.stats$Outlier]
max_Litt <- ifelse(length(outliers) == 0, max(data_temp$LittDep), min(outliers) - 0.1)

# Set parameters 
data <- FuelsDuffLitt_data
query <- "Fuel DL Values LittDep" 
query_message <- paste0("Transect = ", data$Transect, ". ", "Sample Location = ", data$SampLoc, ". ", "Litter Depth")
values_data <- data$LittDep
values_valid <- max_Litt
values_check <- values_data <= values_valid

# Identify errors
errors_FuelsDuffLitt_LittDep <- qaqc(data, query, query_message, values_check)
```

-   Sort by DuffDep. Check that duff depth values are reasonable.

```{r}
# Perform Rosner's Test for outliers using all values
data_temp <- FuelsDuffLitt_all %>%
  filter(!is.na(DuffDep))
data_outlier <- rosnerTest(data_temp$DuffDep)
outliers <- data_outlier$all.stats$Value[data_outlier$all.stats$Outlier]
max_Duff <- ifelse(length(outliers) == 0, max(data_temp$DuffDep), min(outliers) - 0.1)

# Set parameters 
data <- FuelsDuffLitt_data
query <- "Fuel DL Values DuffDep" 
query_message <- paste0("Transect = ", data$Transect, ". ", "Sample Location = ", data$SampLoc, ". ", "Duff Depth")
values_data <- data$DuffDep
values_valid <- max_Duff
values_check <- values_data <= values_valid

# Identify errors
errors_FuelsDuffLitt_DuffDep <- qaqc(data, query, query_message, values_check)
```

#### Combine Values Errors

```{r}
# Combine
errors_FuelsDuffLitt_Values <- unique(rbind(errors_FuelsDuffLitt_TransNum_1, errors_FuelsDuffLitt_TransNum_2, errors_FuelsDuffLitt_LittDep, errors_FuelsDuffLitt_DuffDep))

remove(errors_FuelsDuffLitt_TransNum_1, errors_FuelsDuffLitt_TransNum_2, errors_FuelsDuffLitt_LittDep, errors_FuelsDuffLitt_DuffDep)
```

### Fuel DL Errors

```{r}
# Save to master error list 
# errors_FuelsDuffLitt <- unique(rbind(errors_FuelsDuffLitt_FuelConst, errors_FuelsDuffLitt_Header, errors_FuelsDuffLitt_Hits, errors_FuelsDuffLitt_Values))

errors_FuelsDuffLitt <- rbind(errors_FuelsDuffLitt_FuelConst, errors_blank,  errors_FuelsDuffLitt_Header, errors_blank, errors_FuelsDuffLitt_Hits, errors_blank, errors_FuelsDuffLitt_Values)

remove(errors_FuelsDuffLitt_FuelConst, errors_FuelsDuffLitt_Header, errors_FuelsDuffLitt_Hits, errors_FuelsDuffLitt_Values)
```

```{r}
# Table of results for quick check
#kable(errors_FuelsDuffLitt, "pipe")

# Save as CSV or XLSX
path_errors
#write.csv(errors_FuelsDuffLitt, paste0(path_errors, "errors_GRCA_RAP_FuelsDuffLitt.csv"), quote=FALSE, row.names = FALSE, na = "")
#write_xlsx(errors_FuelsDuffLitt, paste0(path_errors, "errors_GRCA_RAP_FuelsDuffLitt.xlsx"))
```

## FINE FUELS (FWD)

This code conducts quality control checks on fine woody debris (FWD) surface fuels data within the "Surface Fuels - Fine" data set.

It checks for errors in: headers, fuel constants, transect numbers, azimuth, slope, and One/Ten/Hundred Hour count values.

### Fuel Fine Header

[Problem:]{.underline} Incorrect header information entered for RAP plots.

[Procedure:]{.underline}

-   Check that NumTran = 1 for the appropriate project units: Moqui, Picnic, Quarry

```{r}
# Set parameters  
data <- FuelsFine_header %>% 
  filter(MacroPlot.Purpose %in% c("Moqui", "Picnic", "Quarry"))
query <- "Fuel Fine Header NumTran" 
query_message <- "Number of Transects"  
values_data <- data$NumTran  
values_valid <- 1   
values_check <- values_data == values_valid

# Identify errors
errors_FuelsFine_NumTran_1 <- qaqc(data, query, query_message, values_check)
```

-   Check that NumTran = 2 for the appropriate project units: Burnt Corral, Fawn Spring, Hwy 67, Range, Spring Canyon, Thompson, Tipover, Tusayan Pueblo (Thinning)

```{r}
# Set parameters  
data <- FuelsFine_header %>% 
  filter(MacroPlot.Purpose %in% c("Burnt Corral", "Fawn Spring", "Hwy 67", "Range", "Spring Canyon", "Thompson", "Tipover", "Tusayan Pueblo (Thinning)"))
query <- "Fuel Fine Header NumTran" 
query_message <- "Number of Transects"  
values_data <- data$NumTran  
values_valid <-2   
values_check <- values_data == values_valid

# Identify errors
errors_FuelsFine_NumTran_2 <- qaqc(data, query, query_message, values_check)
```

-   Check that OneHrTranLen = 6

```{r}
# Set parameters  
data <- FuelsFine_header
query <- "Fuel Fine Header OneHrTranLen" 
query_message <- "One Hour Transect Length"  
values_data <- data$OneHrTranLen
values_valid <- 6
values_check <- values_data == values_valid

# Identify errors
errors_FuelsFine_OneHrTranLen <- qaqc(data, query, query_message, values_check)
```

-   Check that TenHrTranLen = 6

```{r}
# Set parameters  
data <- FuelsFine_header
query <- "Fuel Fine Header TenHrTranLen" 
query_message <- "Ten Hour Transect Length"  
values_data <- data$TenHrTranLen 
values_valid <- 6
values_check <- values_data == values_valid

# Identify errors
errors_FuelsFine_TenHrTranLen <- qaqc(data, query, query_message, values_check)
```

-   Check that HunHrTranLen = 12

```{r}
# Set parameters  
data <- FuelsFine_header
query <- "Fuel Fine Header HunHrTranLen" 
query_message <- "Hundrend Hour Transect Length"  
values_data <- data$HunHrTranLen 
values_valid <- 12
values_check <- values_data == values_valid

# Identify errors
errors_FuelsFine_HunHrTranLen <- qaqc(data, query, query_message, values_check)
```

#### Combine Header Errors

```{r}
# Combine
errors_FuelsFine_Header <- unique(rbind(errors_FuelsFine_NumTran_1, errors_FuelsFine_NumTran_2, errors_FuelsFine_OneHrTranLen, errors_FuelsFine_TenHrTranLen, errors_FuelsFine_HunHrTranLen))

remove(errors_FuelsFine_NumTran_1, errors_FuelsFine_NumTran_2, errors_FuelsFine_OneHrTranLen, errors_FuelsFine_TenHrTranLen, errors_FuelsFine_HunHrTranLen)
```

### Fuel Fine FuelConst

[Problem:]{.underline} Incorrect fine woody debris fuel constant entered.

[Procedure:]{.underline}

-   Check that FWDFuConSt = Mixed Conifer for the appropriate project units: Fawn Spring, Hwy 67, Range, Spring Canyon, Thompson, Tipover

```{r}
# Set parameters 
data <- FuelsFine_data %>% 
  filter(MacroPlot.Purpose %in% c("Fawn Spring", "Hwy 67", "Range", "Spring Canyon", "Thompson", "Tipover"))
query <- "Fuel Fine FuelConst" 
query_message <- "Fuel Constant" 
values_data <- data$FWDFuConSt 
values_valid <- "Mixed Conifer"  
values_check <- values_data == values_valid

# Identify errors
errors_FuelsFine_FuelConst_MixCon <- qaqc(data, query, query_message, values_check)
```

-   Check that FWDFuConSt = PIPO for the appropriate project units: Burnt Corral, Moqui, Picnic, Quarry

```{r}
# Set parameters 
data <- FuelsFine_data %>% 
  filter(MacroPlot.Purpose %in% c("Burnt Corral", "Moqui", "Picnic", "Quarry"))
query <- "Fuel Fine FuelConst" 
query_message <- "Fuel Constant" 
values_data <- data$FWDFuConSt 
values_valid <- "PIPO"  
values_check <- values_data == values_valid

# Identify errors
errors_FuelsFine_FuelConst_PIPO <- qaqc(data, query, query_message, values_check)
```

-   Check that CWDFuConSt = PIED for the appropriate project units: Tusayan Pueblo (Thinning)

```{r}
# Set parameters 
data <- FuelsFine_data %>% 
  filter(MacroPlot.Purpose %in% c("Tusayan Pueblo (Thinning)"))
query <- "Fuel Fine FuelConst" 
query_message <- "Fuel Constant" 
values_data <- data$FWDFuConSt 
values_valid <- "PIED"  
values_check <- values_data == values_valid

# Identify errors
errors_FuelsFine_FuelConst_PIED <- qaqc(data, query, query_message, values_check)
```

#### Combine FuelConst Errors

```{r}
# Combine
errors_FuelsFine_FuelConst <- unique(rbind(errors_FuelsFine_FuelConst_MixCon, errors_FuelsFine_FuelConst_PIPO, errors_FuelsFine_FuelConst_PIED))

remove(errors_FuelsFine_FuelConst_MixCon, errors_FuelsFine_FuelConst_PIPO, errors_FuelsFine_FuelConst_PIED)
```

### Fuel Fine Hits

[Problem:]{.underline} Extra or missing data points in RAP plots. There should be 1 or 2 transects with 1 sample point per transect. 

[Procedure:]{.underline}

-   1 transect project units: Moqui, Picnic, Quarry
-   Group by Macroplot and Date. Calculate number of hits per plot. Check that sum_hits = 1

```{r}
# Filter NA values. Add number of hits and store in new column
data_temp1 <- FuelsFine_data %>%
  group_by(MacroPlot.Name, Date) %>% 
  dplyr::summarize("sum_hits" = n())

data_temp2 <- FuelsFine_header %>% 
  group_by(MacroPlot.Name, Date) %>% 
  dplyr::summarise()

data_temp <- merge(data_temp1, data_temp2, by = c("MacroPlot.Name","Date"), all = TRUE)
data_temp$sum_hits[is.na(data_temp$sum_hits)] <- 0
remove(data_temp1, data_temp2)

# Set parameters 
data <- merge(FuelsFine_data, data_temp, by = c("MacroPlot.Name", "Date"), all = T) %>% 
  filter(MacroPlot.Purpose %in% c("Moqui", "Picnic", "Quarry"))
query <- "Fuel Fine Hits" 
query_message <- "Complete Transects" 
values_data <- data$sum_hits
values_valid <- 1
values_check <- values_data == values_valid

# Identify errors
errors_FuelsFine_Hits_1 <- qaqc(data, query, query_message, values_check)
```

-   2 transect project units: Burnt Corral, Fawn Spring, Hwy 67, Range, Spring Canyon, Thompson, Tipover, Tusayan Pueblo (Thinning)
-   Group by Macroplot and Date. Calculate number of hits per plot. Check that sum_hits = 2

```{r}
# Filter NA values. Add number of hits and store in new column
data_temp1 <- FuelsFine_data %>%
  group_by(MacroPlot.Name, Date) %>% 
  dplyr::summarize("sum_hits" = n())

data_temp2 <- FuelsFine_header %>% 
  group_by(MacroPlot.Name, Date) %>% 
  dplyr::summarise()

data_temp <- merge(data_temp1, data_temp2, by = c("MacroPlot.Name","Date"), all = TRUE)
data_temp$sum_hits[is.na(data_temp$sum_hits)] <- 0
remove(data_temp1, data_temp2)

# Set parameters 
data <- merge(FuelsFine_data, data_temp, by = c("MacroPlot.Name", "Date"), all = T) %>% 
  filter(MacroPlot.Purpose %in% c("Burnt Corral", "Fawn Spring", "Hwy 67", "Range", "Spring Canyon", "Thompson", "Tipover", "Tusayan Pueblo (Thinning)"))
query <- "Fuel Fine Hits" 
query_message <- "Complete Transects" 
values_data <- data$sum_hits
values_valid <- 2
values_check <- values_data == values_valid

# Identify errors
errors_FuelsFine_Hits_2 <- qaqc(data, query, query_message, values_check)
```

#### Combine Hits Errors

```{r}
# Combine
errors_FuelsFine_Hits <- unique(rbind(errors_FuelsFine_Hits_1, errors_FuelsFine_Hits_2))

remove(errors_FuelsFine_Hits_1, errors_FuelsFine_Hits_2)
```

### Fuel Fine Values

[Problem:]{.underline}  Values for transect, azimuth, slope, and counts for One, Ten, Hundred hour fuels are missing or unreasonable.

[Procedure:]{.underline}

-   Check that Transect = 1 for the appropriate project units: Moqui, Picnic, Quarry

```{r}
# Set parameters
data <- FuelsFine_data %>% 
  filter(MacroPlot.Purpose %in% c("Moqui", "Picnic", "Quarry"))
query <- "Fuel Fine Values TransNum"
query_message <- "Transect Number"
values_data <- data$Transect
values_valid <- c(1)
values_check <- values_data %in% values_valid

# Identify errors
errors_FuelsFine_TransNum_1 <- qaqc(data, query, query_message, values_check)
```

-   Check that Transect = 1 or 2 for the appropriate project units: Burnt Corral, Fawn Spring, Hwy 67, Range, Spring Canyon, Thompson, Tipover, Tusayan Pueblo (Thinning)

```{r}
# Set parameters
data <- FuelsFine_data %>% 
  filter(MacroPlot.Purpose %in% c("Burnt Corral", "Fawn Spring", "Hwy 67", "Range", "Spring Canyon", "Thompson", "Tipover", "Tusayan Pueblo (Thinning)"))
query <- "Fuel Fine Values TransNum"
query_message <- "Transect Number"
values_data <- data$Transect
values_valid <- c(1, 2)
values_check <- values_data %in% values_valid

# Identify errors
errors_FuelsFine_TransNum_2 <- qaqc(data, query, query_message, values_check)
```

-   Check that Azimuth values are reasonable.

```{r}
# Set parameters
data <- FuelsFine_data
query <- "Fuel Fine Values Azimuth"
query_message <- paste0("Transect = ", data$Transect, ". ", "Azimuth")
values_data <- data$Azimuth
values_valid <- seq(0, 359, by = 1)
values_check <- values_data %in% values_valid

# Identify errors
errors_FuelsFine_Azimuth <- qaqc(data, query, query_message, values_check)
```

-   Check that Slope values are reasonable.

```{r}
# Set parameters
data <- FuelsFine_data
query <- "Fuel Fine Values Slope"
query_message <- paste0("Transect = ", data$Transect, ". ", "Slope")
values_data <- data$Slope
values_valid <- seq(0, 40, by = 1)
values_check <- values_data %in% values_valid

# Identify errors
errors_FuelsFine_Slope <- qaqc(data, query, query_message, values_check)
```

-   Check that One Hour values are reasonable.

```{r}
# Perform Rosner's Test for outliers using all values
data_temp <- FuelsFine_all %>%
  filter(!is.na(OneHr))
data_outlier <- rosnerTest(data_temp$OneHr)
outliers <- data_outlier$all.stats$Value[data_outlier$all.stats$Outlier]
max_One <- ifelse(length(outliers) == 0, max(data_temp$OneHr), min(outliers) - 1)

# Set parameters 
data <- FuelsFine_data
query <- "Fuel Fine Values OneHr" 
query_message <- paste0("Transect = ", data$Transect, ". ", "One Hour Count")
values_data <- data$OneHr
values_valid <- seq(0, max_One, by = 1)
values_check <- values_data %in% values_valid

# Identify errors
errors_FuelsFine_OneHr <- qaqc(data, query, query_message, values_check)
```

-   Check that Ten Hour values are reasonable.

```{r}
# Perform Rosner's Test for outliers using all values
data_temp <- FuelsFine_all %>%
  filter(!is.na(TenHr))
data_outlier <- rosnerTest(data_temp$TenHr)
outliers <- data_outlier$all.stats$Value[data_outlier$all.stats$Outlier]
max_Ten <- ifelse(length(outliers) == 0, max(data_temp$TenHr), min(outliers) - 1)

# Set parameters 
data <- FuelsFine_data
query <- "Fuel Fine Values TenHr" 
query_message <- paste0("Transect = ", data$Transect, ". ", "Ten Hour Count")
values_data <- data$TenHr
values_valid <- seq(0, max_Ten, by = 1)
values_check <- values_data %in% values_valid

# Identify errors
errors_FuelsFine_TenHr <- qaqc(data, query, query_message, values_check)
```

-   Check that Hundred Hour values are reasonable.

```{r}
# Perform Rosner's Test for outliers using all values
data_temp <- FuelsFine_all %>%
  filter(!is.na(HunHr))
data_outlier <- rosnerTest(data_temp$HunHr)
outliers <- data_outlier$all.stats$Value[data_outlier$all.stats$Outlier]
max_Hun <- ifelse(length(outliers) == 0, max(data_temp$HunHr), min(outliers) - 1)

# Set parameters 
data <- FuelsFine_data
query <- "Fuel Fine Values HunHr" 
query_message <- paste0("Transect = ", data$Transect, ". ", "Hundred Hour Count") 
values_data <- data$HunHr
values_valid <- seq(0, max_Hun, by = 1)
values_check <- values_data %in% values_valid

# Identify errors
errors_FuelsFine_HunHr <- qaqc(data, query, query_message, values_check)
```

#### Combine Values Errors

```{r}
# Combine
errors_FuelsFine_Values <- unique(rbind(errors_FuelsFine_TransNum_1, errors_FuelsFine_TransNum_2, errors_FuelsFine_Azimuth, errors_FuelsFine_Slope, errors_FuelsFine_OneHr, errors_FuelsFine_TenHr, errors_FuelsFine_HunHr))

remove(errors_FuelsFine_TransNum_1, errors_FuelsFine_TransNum_2, errors_FuelsFine_Azimuth, errors_FuelsFine_Slope, errors_FuelsFine_OneHr, errors_FuelsFine_TenHr, errors_FuelsFine_HunHr)
```

### Fuel Fine Errors

```{r}
# Save to master error list 
# errors_FuelsFine <- unique(rbind(errors_FuelsFine_FuelConst, errors_FuelsFine_Header, errors_FuelsFine_Hits, errors_FuelsFine_Values))

errors_FuelsFine <- rbind(errors_FuelsFine_FuelConst, errors_blank,  errors_FuelsFine_Header, errors_blank, errors_FuelsFine_Hits, errors_blank, errors_FuelsFine_Values)

remove(errors_FuelsFine_FuelConst, errors_FuelsFine_Header, errors_FuelsFine_Hits, errors_FuelsFine_Values)
```

```{r}
# Table of results for quick check
#kable(errors_FuelsFine, "pipe")

# Save as CSV or XLSX 
path_errors
#write.csv(errors_FuelsFine, paste0(path_errors, "errors_GRCA_RAP_FuelsFine.csv"), quote=FALSE, row.names = FALSE, na = "") 
#write_xlsx(errors_FuelsFine, paste0(path_errors, "errors_GRCA_RAP_FuelsFine.xlsx"))
```

# PROTOCOL - POST BURN

This code conducts quality control checks on post burn data within the "Post Burn Severity" data set.

It checks for errors in: headers, substrate, and vegetation values.

### PBSev Header

[Problem:]{.underline} Incorrect header information entered for RAP plots.

[Procedure:]{.underline}

-   Check that NumTran = 1 for the appropriate project units: Moqui, Picnic, Quarry

```{r}
# Set parameters  
data <- PostBurn_header %>% 
  filter(MacroPlot.Purpose %in% c("Moqui", "Picnic", "Quarry"))
query <- "PBSev Header NumTran" 
query_message <- "Number of Transects"  
values_data <- data$NumTran  
values_valid <- 1   
values_check <- values_data == values_valid

# Identify errors
errors_PostBurn_NumTran_1 <- qaqc(data, query, query_message, values_check)
```

-   Check that NumTran = 2 for the appropriate project units: Burnt Corral, Fawn Spring, Hwy 67, Range, Spring Canyon, Thompson, Tipover, Tusayan Pueblo (Thinning)

```{r}
# Set parameters
data <- PostBurn_header %>% 
  filter(MacroPlot.Purpose %in% c("Burnt Corral", "Fawn Spring", "Hwy 67", "Range", "Spring Canyon", "Thompson", "Tipover", "Tusayan Pueblo (Thinning)"))
query <- "PBSev Header NumTran"
query_message <- "Number of Transects"
values_data <- data$NumTran
values_valid <- 2
values_check <- values_data == values_valid

# Identify errors
errors_PostBurn_NumTran_2 <- qaqc(data, query, query_message, values_check)
```

-   Check that TranLen = 50

```{r}
# Set parameters
data <- PostBurn_header
query <- "PBSev Header TranLen"
query_message <- "Transect Length"
values_data <- data$TranLen
values_valid <- 50
values_check <- values_data == values_valid

# Identify errors
errors_PostBurn_TranLen <- qaqc(data, query, query_message, values_check)
```

-   Check that NumPtsTran = 10

```{r}
# Set parameters
data <- PostBurn_header
query <- "PBSev Header NumPtsTran"
query_message <- "Number of Points"
values_data <- data$NumPtsTran
values_valid <- 10
values_check <- values_data == values_valid

# Identify errors
errors_PostBurn_NumPtsTran <- qaqc(data, query, query_message, values_check)
```

#### Combine Header Errors

```{r}
# Combine
errors_PostBurn_Header <- unique(rbind(errors_PostBurn_NumTran_1, errors_PostBurn_NumTran_2, errors_PostBurn_TranLen, errors_PostBurn_NumPtsTran))

remove(errors_PostBurn_NumTran_1, errors_PostBurn_NumTran_2, errors_PostBurn_TranLen, errors_PostBurn_NumPtsTran)
```

### PBSev Hits

[Problem:]{.underline} Extra or missing data points in RAP plots. There should be 1 or 2 transects with 10 sample points per transect.

[Procedure:]{.underline}

-   1 transect project units: Moqui, Picnic, Quarry
-   Group by Macroplot and Date. Calculate number of hits per plot. Check that sum_hits = 10

```{r}
# Filter NA values. Add number of hits and store in new column
data_temp1 <- PostBurn_data %>%
  filter(!is.na(Veg)) %>%
  filter(!is.na(Sub)) %>% 
  group_by(MacroPlot.Name, Date) %>% 
  dplyr::summarise("sum_hits" = n())

data_temp2 <- PostBurn_header %>% 
  group_by(MacroPlot.Name, Date) %>% 
  dplyr::summarise()

data_temp <- merge(data_temp1, data_temp2, by = c("MacroPlot.Name","Date"), all = TRUE)
data_temp$sum_hits[is.na(data_temp$sum_hits)] <- 0
remove(data_temp1, data_temp2)

# Set parameters 
data <- merge(PostBurn_data, data_temp, by = c("MacroPlot.Name", "Date"), all = T) %>% 
  filter(MacroPlot.Purpose %in% c("Moqui", "Picnic", "Quarry"))
query <- "PBSev Hits" 
query_message <- "Complete Sample Locations"
values_data <- data$sum_hits
values_valid <- 10
values_check <- values_data == values_valid

# Identify errors
errors_PostBurn_Hits_10 <- qaqc(data, query, query_message, values_check)
```

-   2 transect project units: Burnt Corral, Fawn Spring, Hwy 67, Range, Spring Canyon, Thompson, Tipover, Tusayan Pueblo (Thinning)
-   Group by Macroplot and Date. Calculate number of hits per plot. Check that sum_hits = 20

```{r}
# Filter NA values. Add number of hits and store in new column
data_temp1 <- PostBurn_data %>%
  filter(!is.na(Veg)) %>%
  filter(!is.na(Sub)) %>% 
  group_by(MacroPlot.Name, Date) %>% 
  dplyr::summarise("sum_hits" = n())

data_temp2 <- PostBurn_header %>% 
  group_by(MacroPlot.Name, Date) %>% 
  dplyr::summarise()

data_temp <- merge(data_temp1, data_temp2, by = c("MacroPlot.Name","Date"), all = TRUE)
data_temp$sum_hits[is.na(data_temp$sum_hits)] <- 0
remove(data_temp1, data_temp2)

# Set parameters 
data <- merge(PostBurn_data, data_temp, by = c("MacroPlot.Name", "Date"), all = T) %>% 
  filter(MacroPlot.Purpose %in% c("Burnt Corral", "Fawn Spring", "Hwy 67", "Range", "Spring Canyon", "Thompson", "Tipover", "Tusayan Pueblo (Thinning)"))
query <- "PBSev Hits" 
query_message <- "Complete Sample Locations"
values_data <- data$sum_hits
values_valid <- 20
values_check <- values_data == values_valid

# Identify errors
errors_PostBurn_Hits_20 <- qaqc(data, query, query_message, values_check)
```

#### Combine Hits Errors

```{r}
# Combine
errors_PostBurn_Hits <- unique(rbind(errors_PostBurn_Hits_10, errors_PostBurn_Hits_20))

remove(errors_PostBurn_Hits_10, errors_PostBurn_Hits_20)
```

### PBSev Values

[Problem:]{.underline} Incorrect values entered for transect, substrate, and vegetation.

[Procedure:]{.underline}

-   Check that Transect = 1 for the appropriate project units: Moqui, Picnic, Quarry

```{r}
# Set parameters
data <- PostBurn_data %>% 
  filter(MacroPlot.Purpose %in% c("Moqui", "Picnic", "Quarry"))
query <- "PBSev Values TransNum"
query_message <- "Transect Number"
values_data <- data$Transect
values_valid <- c(1)
values_check <- values_data %in% values_valid

# Identify errors
errors_PostBurn_TransNum_1 <- qaqc(data, query, query_message, values_check)
```

-   Check that Transect = 1 or 2 for the appropriate project units: Burnt Corral, Fawn Spring, Hwy 67, Range, Spring Canyon, Thompson, Tipover, Tusayan Pueblo (Thinning)

```{r}
# Set parameters
data <- PostBurn_data %>% 
  filter(MacroPlot.Purpose %in% c("Burnt Corral", "Fawn Spring", "Hwy 67", "Range", "Spring Canyon", "Thompson", "Tipover", "Tusayan Pueblo (Thinning)"))
query <- "PBSev Values TransNum"
query_message <- "Transect Number"
values_data <- data$Transect
values_valid <- c(1, 2)
values_check <- values_data %in% values_valid

# Identify errors
errors_PostBurn_TransNum_2 <- qaqc(data, query, query_message, values_check)
```

-   Check that Sub = 0, 1, 2, 3, 4, or 5

```{r}
# Set parameters
data <- PostBurn_data
query <- "PBSev Values Substrate"
query_message <- paste0("Transect = ", data$Transect, ". ", "Point = ", data$Point, ". ", "Substrate Severity")
values_data <- data$Sub
values_valid <- c(0, 1, 2, 3, 4, 5)
values_check <- values_data %in% values_valid

# Identify errors
errors_PostBurn_Sub <- qaqc(data, query, query_message, values_check)
```

-   Check that Veg = 0, 1, 2, 3, 4, or 5

```{r}
# Set parameters
data <- PostBurn_data
query <- "PBSev Values Veg"
query_message <- paste0("Transect = ", data$Transect, ". ", "Point = ", data$Point, ". ", "Vegetation Severity")
values_data <- data$Veg
values_valid <- c(0, 1, 2, 3, 4, 5)
values_check <- values_data %in% values_valid

# Identify errors
errors_PostBurn_Veg <- qaqc(data, query, query_message, values_check)
```

#### Combine Values Errors

```{r}
# Combine
errors_PostBurn_Values <- unique(rbind(errors_PostBurn_TransNum_1, errors_PostBurn_TransNum_2, errors_PostBurn_Sub, errors_PostBurn_Veg))

remove(errors_PostBurn_TransNum_1, errors_PostBurn_TransNum_2, errors_PostBurn_Sub, errors_PostBurn_Veg)
```

### PBSev Errors

```{r}
# Save to master error list
# errors_PostBurn <- unique(rbind(errors_PostBurn_Header, errors_PostBurn_Hits, errors_PostBurn_Values))

errors_PostBurn <- rbind(errors_PostBurn_Header, errors_blank, errors_PostBurn_Hits, errors_blank, errors_PostBurn_Values)

remove(errors_PostBurn_Header, errors_PostBurn_Hits, errors_PostBurn_Values)
```

```{r}
# Table of results for quick check
#kable(errors_PostBurn, "pipe")

# Save as CSV or XLSX
path_errors
#write.csv(errors_PostBurn, paste0(path_errors, "errors_GRCA_RAP_PostBurn.csv"), quote=FALSE, row.names = FALSE, na = "")
#write_xlsx(errors_PostBurn, paste0(path_errors, "errors_GRCA_RAP_PostBurn.xlsx"))
```

# PROTOCOL - TREES

This code conducts quality control checks on tree data within the "Trees - Individuals (metric)" data set.

It checks for errors in: headers, crown base height, crown class, damage codes, DBH, dead and down, duplicates, subplot fractions, height, life form, non-post severity, post severity, status, and user variables.

### Trees Header

[Problem:]{.underline} Incorrect header information entered for RAP plots.

[Procedure:]{.underline}

-   Check that MacroPlotSize = 0.03

```{r}
# Set parameters  
data <- Trees_header
query <- "Trees Header MacroPlotSize" 
query_message <- "Macro Plot Size"  
values_data <- data$MacroPlotSize  
values_valid <- 0.03    
values_check <- values_data == values_valid

# Identify errors
errors_Trees_MacroPlotSize <- qaqc(data, query, query_message, values_check)
```

-   Check that SnagPlotSize = 0.03

```{r}
# Set parameters  
data <- Trees_header
query <- "Trees Header SnagPlotSize" 
query_message <- "Snag Plot Size"  
values_data <- data$SnagPlotSize
values_valid <- 0.03 
values_check <- values_data == values_valid

# Identify errors
errors_Trees_SnagPlotSize <- qaqc(data, query, query_message, values_check)
```

-   Check that BrkPntDia = 15

```{r}
# Set parameters  
data <- Trees_header
query <- "Trees Header BrkPntDia" 
query_message <- "Break Point Diameter"  
values_data <- data$BrkPntDia
values_valid <- 15
values_check <- values_data == values_valid

# Identify errors
errors_Trees_BrkPntDia <- qaqc(data, query, query_message, values_check)
```

#### Combine Header Errors

```{r}
# Save to master error list 
errors_Trees_Header <- unique(rbind(errors_Trees_MacroPlotSize, errors_Trees_SnagPlotSize, errors_Trees_BrkPntDia))

remove(errors_Trees_MacroPlotSize, errors_Trees_SnagPlotSize, errors_Trees_BrkPntDia)
```

### Trees Hits

[Problem:]{.underline} Extra or missing data points in FMH plots. Plots with no trees should be verified.

[Procedure:]{.underline}

-   Group by Macroplot and Date. Calculate number of hits per plot. Check that sum_hits \> 0

```{r}
# Filter NA values. Add number of hits and store in new column
data_temp1 <- Trees_data %>%
  group_by(MacroPlot.Name, Date) %>% 
  dplyr::summarize("sum_hits" = n())

data_temp2 <- Trees_header %>% 
  group_by(MacroPlot.Name, Date) %>% 
  dplyr::summarise()

data_temp <- merge(data_temp1, data_temp2, by = c("MacroPlot.Name","Date"), all = TRUE)
data_temp$sum_hits[is.na(data_temp$sum_hits)] <- 0
remove(data_temp1, data_temp2)

# Set parameters 
data <- merge(Trees_data, data_temp, by = c("MacroPlot.Name", "Date"), all = T)
query <- "Trees Hits" 
query_message <- "Trees" 
values_data <- data$sum_hits
values_valid <- 0
values_check <- values_data > values_valid

# Identify errors
errors_Trees_Hits <- qaqc(data, query, query_message, values_check)
```

### Trees CBH

#### Trees CBH Live

[Problem]{.underline}: Live overstory trees do not have live crown base height entered.

[Procedure:]{.underline}

-   Sort by Status. If Status = L, then check that LiCrBHt is [not]{.underline} blank

```{r}
# Set parameters 
data <- Trees_data %>% 
  filter(Status == "L", DBH > 15.0)
data$LiCrBHt[is.na(data$LiCrBHt)] <- ""
query <- "Trees CBH Live" 
query_message <- paste0("Status = L. DBH = overstory. Live Crown Base Height")
values_data <- data$LiCrBHt
values_valid <- ""
values_check <- values_data != values_valid

# Identify errors
errors_Trees_CBH_Live <- qaqc(data, query, query_message, values_check)
```

#### Trees CBH Dead

[Problem]{.underline}: Dead trees have live crown base height entered.

[Procedure:]{.underline}

-   Sort by Status. If Status = D, then check that LiCrBHt = blank

```{r}
# Set parameters 
data <- Trees_data %>% 
  filter(Status == "D")
data$LiCrBHt[is.na(data$LiCrBHt)] <- ""
query <- "Trees CBH Dead" 
query_message <- paste0("Tag ", data$TagNo, ". ", "Status = D. Live Crown Base Height")
values_data <- data$LiCrBHt
values_valid <- ""
values_check <- values_data == values_valid

# Identify errors
errors_Trees_CBH_Dead <- qaqc(data, query, query_message, values_check)
```

#### Trees CBH vs Ht

[Problem]{.underline}: Check that Live Crown Base Height is shorter than total tree Height

[Procedure:]{.underline}

-   Check that LiCrBHt \< Ht

```{r}
# Set parameters
data <- Trees_data %>% 
  filter(!is.na(LiCrBHt), Status == "L")
query <- "Trees CBH vs Ht" 
query_message <- paste0("Tag ", data$TagNo, ". ", "Height shorter than CBH. CBH")
values_data <- data$LiCrBHt
values_valid <- data$Ht
values_check <- values_data < values_valid

# Identify errors
errors_Trees_CBH_Ht <- qaqc(data, query, query_message, values_check)
```

#### Combine CBH Errors

```{r}
# Combine
errors_Trees_CBH <- unique(rbind(errors_Trees_CBH_Live, errors_Trees_CBH_Dead, errors_Trees_CBH_Ht))

remove(errors_Trees_CBH_Live, errors_Trees_CBH_Dead, errors_Trees_CBH_Ht)
```

### Trees Crown Class

[Problem]{.underline}: Incompatible values entered for tree crown class.

[Procedure:]{.underline}

-   Filter by Status = D and DBH = blank. Check that CrwnCl = BBD, CUS, or DD

```{r}
# Set parameters  
data <- Trees_data %>% 
  filter(is.na(DBH), Status == "D")
query <- "Trees Crown Class Dead" 
query_message <- paste0("Tag ", data$TagNo, ". ", "Status = D. DBH = blank. Crown Class")  
values_data <- data$CrwnCl
values_valid <- c("DD", "BBD", "CUS")
values_check <- values_data %in% values_valid

# Identify errors
errors_Trees_CrwnCl_1 <- qaqc(data, query, query_message, values_check)
```

-   Filter by Status = L and DBH = blank. Check that CrwnCl = blank

```{r}
# Set parameters 
data <- Trees_data %>% 
  filter(is.na(DBH), Status == "L")
query <- "Trees Crown Class Live" 
query_message <- paste0("Tag ", data$TagNo, ". ", "Status = L. DBH = blank. Crown Class")  
values_data <- data$CrwnCl
values_valid <- ""
values_check <- values_data == values_valid

# Identify errors
errors_Trees_CrwnCl_2 <- qaqc(data, query, query_message, values_check)
```

-   Filter by Status = D and DBH = Overstory. Check that CrwnCl = BAD, CS, LBS, or RS or blank

```{r}
# Set parameters 
data <- Trees_data %>% 
  filter(DBH > 15.0, Status == "D")
query <- "Trees Crown Class Overstory Dead" 
query_message <- paste0("Tag ", data$TagNo, ". ", "Status = D. DBH = overstory. Crown Class")
values_data <- data$CrwnCl
values_valid <- c("BAD", "CS", "LBS", "RS")
values_check <- values_data %in% values_valid

# Identify errors
errors_Trees_CrwnCl_3 <- qaqc(data, query, query_message, values_check)
```

-   Filter by Status = L and DBH = Overstory. Check that CrwnCl = C, D, I, O, or SC or blank

```{r}
# Set parameters 
data <- Trees_data %>% 
  filter(DBH > 15.0, Status == "L")
query <- "Trees Crown Class Overstory Live" 
query_message <- paste0("Tag ", data$TagNo, ". ", "Status = L. DBH = overstory. Crown Class") 
values_data <- data$CrwnCl
values_valid <- c("C", "D", "I", "O", "SC")
values_check <- values_data %in% values_valid

# Identify errors
errors_Trees_CrwnCl_4 <- qaqc(data, query, query_message, values_check)
```

-   Filter by DBH = Pole. Check that CrwnCl = X or blank

```{r}
# Set parameters 
data <- Trees_data %>% 
  filter(DBH <= 15.0)
query <- "Trees Crown Class Pole" 
query_message <- paste0("Tag ", data$TagNo, ". ", "DBH = pole. Crown Class") 
values_data <- data$CrwnCl
values_valid <- c("X", "")
values_check <- values_data %in% values_valid

# Identify errors
errors_Trees_CrwnCl_5 <- qaqc(data, query, query_message, values_check)
```

#### Combine Crown Class Errors

```{r}
# Save to master error list 
errors_Trees_CrwnCl <- unique(rbind(errors_Trees_CrwnCl_1, errors_Trees_CrwnCl_2, errors_Trees_CrwnCl_3, errors_Trees_CrwnCl_4, errors_Trees_CrwnCl_5))

remove(errors_Trees_CrwnCl_1, errors_Trees_CrwnCl_2, errors_Trees_CrwnCl_3, errors_Trees_CrwnCl_4, errors_Trees_CrwnCl_5)
```

### Trees Damage

#### Trees Damage Live

[Problem]{.underline}: Tree damage codes are entered incorrectly.

[Procedure:]{.underline}

-   Sort by DamCd 1. Check that DamCd 1 corresponds to one of the choices on the FMH-1 overstory data sheets.

```{r}
# Make sure damage codes are blank vs NA
Trees_data$DamCd1[is.na(Trees_data$DamCd1)] <- ""
Trees_data$DamCd2[is.na(Trees_data$DamCd2)] <- ""
Trees_data$DamCd3[is.na(Trees_data$DamCd3)] <- ""
Trees_data$DamCd4[is.na(Trees_data$DamCd4)] <- ""
Trees_data$DamCd5[is.na(Trees_data$DamCd5)] <- ""
```

```{r}
# Set parameters 
data <- Trees_data %>% 
  filter(Status == "L")
query <- "Trees Damage Live" 
query_message <- paste0("Tag ", data$TagNo, ". ", "Status = L. Damage Code 1")  
values_data <- data$DamCd1
values_valid <- c("", "ABGR", "BIRD", "BLIG", "BROK", "BROM", "BURL", "CONK", "CROK", "DTOP", "EPIC", "EPIP", "FIRE", "FORK", "FRST", "GALL", "HOLW", "INSE", "LEAN", "LICH", "LIGT", "MAMM", "MISL", "MOSS", "OZON", "ROOT", "ROTT", "SPAR", "SPRT", "TWIN", "UMAN", "WOND")
values_check <- values_data %in% values_valid

# Identify errors
errors_Trees_DamCd_L_1 <- qaqc(data, query, query_message, values_check)
```

-   Sort by DamCd 2. Check that DamCd 2 corresponds to one of the choices on the FMH-1 overstory data sheets.

```{r}
# Set parameters 
data <- Trees_data %>% 
  filter(Status == "L")
query <- "Trees Damage Live" 
query_message <- paste0("Tag ", data$TagNo, ". ", "Status = L. Damage Code 2")  
values_data <- data$DamCd2
values_valid <- c("", "ABGR", "BIRD", "BLIG", "BROK", "BROM", "BURL", "CONK", "CROK", "DTOP", "EPIC", "EPIP", "FIRE", "FORK", "FRST", "GALL", "HOLW", "INSE", "LEAN", "LICH", "LIGT", "MAMM", "MISL", "MOSS", "OZON", "ROOT", "ROTT", "SPAR", "SPRT", "TWIN", "UMAN", "WOND")
values_check <- values_data %in% values_valid

# Identify errors
errors_Trees_DamCd_L_2 <- qaqc(data, query, query_message, values_check)
```

-   Sort by DamCd 3. Check that DamCd 3 corresponds to one of the choices on the FMH-1 overstory data sheets.

```{r}
# Set parameters 
data <- Trees_data %>% 
  filter(Status == "L")
query <- "Trees Damage Live" 
query_message <- paste0("Tag ", data$TagNo, ". ", "Status = L. Damage Code 3") 
values_data <- data$DamCd3
values_valid <- c("", "ABGR", "BIRD", "BLIG", "BROK", "BROM", "BURL", "CONK", "CROK", "DTOP", "EPIC", "EPIP", "FIRE", "FORK", "FRST", "GALL", "HOLW", "INSE", "LEAN", "LICH", "LIGT", "MAMM", "MISL", "MOSS", "OZON", "ROOT", "ROTT", "SPAR", "SPRT", "TWIN", "UMAN", "WOND")
values_check <- values_data %in% values_valid

# Identify errors
errors_Trees_DamCd_L_3 <- qaqc(data, query, query_message, values_check)
```

-   Sort by DamCd 4. Check that DamCd 4 corresponds to one of the choices on the FMH-1 overstory data sheets.

```{r}
# Set parameters 
data <- Trees_data %>% 
  filter(Status == "L")
query <- "Trees Damage Live" 
query_message <- paste0("Tag ", data$TagNo, ". ", "Status = L. Damage Code 4")  
values_data <- data$DamCd4
values_valid <- c("", "ABGR", "BIRD", "BLIG", "BROK", "BROM", "BURL", "CONK", "CROK", "DTOP", "EPIC", "EPIP", "FIRE", "FORK", "FRST", "GALL", "HOLW", "INSE", "LEAN", "LICH", "LIGT", "MAMM", "MISL", "MOSS", "OZON", "ROOT", "ROTT", "SPAR", "SPRT", "TWIN", "UMAN", "WOND")
values_check <- values_data %in% values_valid

# Identify errors
errors_Trees_DamCd_L_4 <- qaqc(data, query, query_message, values_check)
```

-   Sort by DamCd 5. Check that DamCd 5 corresponds to one of the choices on the FMH-1 overstory data sheets.

```{r}
# Set parameters 
data <- Trees_data %>% 
  filter(Status == "L")
query <- "Trees Damage Live" 
query_message <- paste0("Tag ", data$TagNo, ". ", "Status = L. Damage Code 5")  
values_data <- data$DamCd5
values_valid <- c("", "ABGR", "BIRD", "BLIG", "BROK", "BROM", "BURL", "CONK", "CROK", "DTOP", "EPIC", "EPIP", "FIRE", "FORK", "FRST", "GALL", "HOLW", "INSE", "LEAN", "LICH", "LIGT", "MAMM", "MISL", "MOSS", "OZON", "ROOT", "ROTT", "SPAR", "SPRT", "TWIN", "UMAN", "WOND")
values_check <- values_data %in% values_valid

# Identify errors
errors_Trees_DamCd_L_5 <- qaqc(data, query, query_message, values_check)
```

#### Trees Damage Dead

[Problem]{.underline}: Damage codes entered for trees that are dead.

[Procedure:]{.underline}

-   Sort by Status. If Status = D, check that DamCd1, DamCd2, DamCd3, DamCd4, [and]{.underline} DamCd5 are blank.

```{r}
# Set parameters 
data <- Trees_data %>% 
  filter(Status == "D")
query <- "Trees Damage Dead" 
query_message <- paste0("Tag ", data$TagNo, ". ", "Status = D. Damage Code 1")
values_data <- data$DamCd1
values_valid <- ""
values_check <- values_data %in% values_valid

# Identify errors
errors_Trees_DamCd_D_1 <- qaqc(data, query, query_message, values_check)
```

```{r}
# Set parameters 
data <- Trees_data %>% 
  filter(Status == "D")
query <- "Trees Damage Dead" 
query_message <- paste0("Tag ", data$TagNo, ". ", "Status = D. Damage Code 2")  
values_data <- data$DamCd2
values_valid <- ""
values_check <- values_data %in% values_valid

# Identify errors
errors_Trees_DamCd_D_2 <- qaqc(data, query, query_message, values_check)
```

```{r}
# Set parameters 
data <- Trees_data %>% 
  filter(Status == "D")
query <- "Trees Damage Dead" 
query_message <- paste0("Tag ", data$TagNo, ". ", "Status = D. Damage Code 3")
values_data <- data$DamCd3
values_valid <- ""
values_check <- values_data %in% values_valid

# Identify errors
errors_Trees_DamCd_D_3 <- qaqc(data, query, query_message, values_check)
```

```{r}
# Set parameters 
data <- Trees_data %>% 
  filter(Status == "D")
query <- "Trees Damage Dead" 
query_message <- paste0("Tag ", data$TagNo, ". ", "Status = D. Damage Code 4")
values_data <- data$DamCd4
values_valid <- ""
values_check <- values_data %in% values_valid

# Identify errors
errors_Trees_DamCd_D_4 <- qaqc(data, query, query_message, values_check)
```

```{r}
# Set parameters 
data <- Trees_data %>% 
  filter(Status == "D")
query <- "Trees Damage Dead" 
query_message <- paste0("Tag ", data$TagNo, ". ", "Status = D. Damage Code 5")
values_data <- data$DamCd5
values_valid <- ""
values_check <- values_data %in% values_valid

# Identify errors
errors_Trees_DamCd_D_5 <- qaqc(data, query, query_message, values_check)
```

#### Trees Damage Blank

[Problem]{.underline}: Tree damage codes are entered incorrectly. Blank damages exist before entered damages

[Procedure:]{.underline}

-   Filter for DamCd1 = blank. Check that DamCd2, DamCd3, DamCd4, [and]{.underline} DamCd5 are blank.

```{r}
# Set parameters 
data <- Trees_data %>% 
  filter(DamCd1 == "")
query <- "Trees Damage 1 Blank" 
query_message <- paste0("Tag ", data$TagNo, ". ", "Damage Code 1 = Blank, Damage Code 2")
values_data <- data$DamCd2
values_valid <- ""
values_check <- values_data %in% values_valid

# Identify errors
errors_Trees_DamCd_1_Blank_2 <- qaqc(data, query, query_message, values_check)
```

```{r}
# Set parameters 
data <- Trees_data %>% 
  filter(DamCd1 == "")
query <- "Trees Damage 1 Blank" 
query_message <- paste0("Tag ", data$TagNo, ". ", "Damage Code 1 = Blank, Damage Code 3")
values_data <- data$DamCd3
values_valid <- ""
values_check <- values_data %in% values_valid

# Identify errors
errors_Trees_DamCd_1_Blank_3 <- qaqc(data, query, query_message, values_check)
```

```{r}
# Set parameters 
data <- Trees_data %>% 
  filter(DamCd1 == "")
query <- "Trees Damage 1 Blank" 
query_message <- paste0("Tag ", data$TagNo, ". ", "Damage Code 1 = Blank, Damage Code 4")
values_data <- data$DamCd4
values_valid <- ""
values_check <- values_data %in% values_valid

# Identify errors
errors_Trees_DamCd_1_Blank_4 <- qaqc(data, query, query_message, values_check)
```

```{r}
# Set parameters 
data <- Trees_data  %>% 
  filter(DamCd1 == "")
query <- "Trees Damage 1 Blank" 
query_message <- paste0("Tag ", data$TagNo, ". ", "Damage Code 1 = Blank, Damage Code 5")
values_data <- data$DamCd5
values_valid <- ""
values_check <- values_data %in% values_valid

# Identify errors
errors_Trees_DamCd_1_Blank_5 <- qaqc(data, query, query_message, values_check)
```

-   Filter for DamCd2 = blank. Check that DamCd3, DamCd4, [and]{.underline} DamCd5 are blank.

```{r}
# Set parameters 
data <- Trees_data %>% 
  filter(DamCd2 == "")
query <- "Trees Damage 2 Blank" 
query_message <- paste0("Tag ", data$TagNo, ". ", "Damage Code 2 = Blank, Damage Code 3")
values_data <- data$DamCd3
values_valid <- ""
values_check <- values_data %in% values_valid

# Identify errors
errors_Trees_DamCd_2_Blank_3 <- qaqc(data, query, query_message, values_check)
```

```{r}
# Set parameters 
data <- Trees_data %>% 
  filter(DamCd2 == "")
query <- "Trees Damage 2 Blank" 
query_message <- paste0("Tag ", data$TagNo, ". ", "Damage Code 2 = Blank, Damage Code 4")
values_data <- data$DamCd4
values_valid <- ""
values_check <- values_data %in% values_valid

# Identify errors
errors_Trees_DamCd_2_Blank_4 <- qaqc(data, query, query_message, values_check)
```

```{r}
# Set parameters 
data <- Trees_data %>% 
  filter(DamCd2 == "")
query <- "Trees Damage 2 Blank" 
query_message <- paste0("Tag ", data$TagNo, ". ", "Damage Code 2 = Blank, Damage Code 5")
values_data <- data$DamCd5
values_valid <- ""
values_check <- values_data %in% values_valid

# Identify errors
errors_Trees_DamCd_2_Blank_5 <- qaqc(data, query, query_message, values_check)
```

-   Filter for DamCd3 = blank. Check that DamCd4 [and]{.underline} DamCd5 are blank.

```{r}
# Set parameters 
data <- Trees_data %>% 
  filter(DamCd3 == "")
query <- "Trees Damage 3 Blank" 
query_message <- paste0("Tag ", data$TagNo, ". ", "Damage Code 3 = Blank, Damage Code 4")
values_data <- data$DamCd4
values_valid <- ""
values_check <- values_data %in% values_valid

# Identify errors
errors_Trees_DamCd_3_Blank_4 <- qaqc(data, query, query_message, values_check)
```

```{r}
# Set parameters 
data <- Trees_data %>% 
  filter(DamCd3 == "")
query <- "Trees Damage 3 Blank" 
query_message <- paste0("Tag ", data$TagNo, ". ", "Damage Code 3 = Blank, Damage Code 5")
values_data <- data$DamCd5
values_valid <- ""
values_check <- values_data %in% values_valid

# Identify errors
errors_Trees_DamCd_3_Blank_5 <- qaqc(data, query, query_message, values_check)
```

-   Filter for DamCd4 = blank. Check that DamCd5 is blank.

```{r}
# Set parameters 
data <- Trees_data %>% 
  filter(DamCd4 == "")
query <- "Trees Damage 4 Blank" 
query_message <- paste0("Tag ", data$TagNo, ". ", "Damage Code 4 = Blank, Damage Code 5")
values_data <- data$DamCd5
values_valid <- ""
values_check <- values_data %in% values_valid

# Identify errors
errors_Trees_DamCd_4_Blank_5 <- qaqc(data, query, query_message, values_check)
```

#### Combine Damage Errors

```{r}
# Damage Errors Live Trees
errors_Trees_DamCd_L <- unique(rbind(errors_Trees_DamCd_L_1, errors_Trees_DamCd_L_2, errors_Trees_DamCd_L_3, errors_Trees_DamCd_L_4, errors_Trees_DamCd_L_5))

remove(errors_Trees_DamCd_L_1, errors_Trees_DamCd_L_2, errors_Trees_DamCd_L_3, errors_Trees_DamCd_L_4, errors_Trees_DamCd_L_5)

# Damage Errors Dead Trees
errors_Trees_DamCd_D <- unique(rbind(errors_Trees_DamCd_D_1, errors_Trees_DamCd_D_2, errors_Trees_DamCd_D_3, errors_Trees_DamCd_D_4, errors_Trees_DamCd_D_5))

remove(errors_Trees_DamCd_D_1, errors_Trees_DamCd_D_2, errors_Trees_DamCd_D_3, errors_Trees_DamCd_D_4, errors_Trees_DamCd_D_5)

# Damage Errors Blank Entries
errors_Trees_DamCd_Blank <- unique(rbind(errors_Trees_DamCd_1_Blank_2, errors_Trees_DamCd_1_Blank_3, errors_Trees_DamCd_1_Blank_4, errors_Trees_DamCd_1_Blank_5, errors_Trees_DamCd_2_Blank_3, errors_Trees_DamCd_2_Blank_4, errors_Trees_DamCd_2_Blank_5, errors_Trees_DamCd_3_Blank_4, errors_Trees_DamCd_3_Blank_5, errors_Trees_DamCd_4_Blank_5))

remove(errors_Trees_DamCd_1_Blank_2, errors_Trees_DamCd_1_Blank_3, errors_Trees_DamCd_1_Blank_4, errors_Trees_DamCd_1_Blank_5, errors_Trees_DamCd_2_Blank_3, errors_Trees_DamCd_2_Blank_4, errors_Trees_DamCd_2_Blank_5, errors_Trees_DamCd_3_Blank_4, errors_Trees_DamCd_3_Blank_5, errors_Trees_DamCd_4_Blank_5)

# Damage Errors Combined
errors_Trees_DamCd <- unique(rbind(errors_Trees_DamCd_L, errors_Trees_DamCd_D, errors_Trees_DamCd_Blank))

remove(errors_Trees_DamCd_L, errors_Trees_DamCd_D, errors_Trees_DamCd_Blank)
                                  
```

### Trees DBH

[Problem]{.underline}: DBH values smaller than sampling parameters or excessively large. DBH values for standing trees do not exist.

[Procedure:]{.underline}

-   Filter to exclude DD trees. Check that DBH ≥ 15.1.

```{r}
# Set parameters 
data <- Trees_data %>% 
  filter(!CrwnCl %in% c("DD", "BBD", "CUS"))
query <- "Trees DBH Min" 
query_message <- paste0("Tag ", data$TagNo, ". ", "DBH")
values_data <- data$DBH
values_valid <- min(15.1)
values_check <- values_data >= values_valid

# Identify errors
errors_Trees_DBH_Min <- qaqc(data, query, query_message, values_check)
```

-   Filter to exclude DD trees. Check that DBH is not excessively large. Check that DBH values for standing trees exist.

```{r}
# Perform Rosner's Test for outliers using all values
data_temp <- Trees_all %>%
  filter(!is.na(DBH))
data_outlier <- rosnerTest(data_temp$DBH)
outliers <- data_outlier$all.stats$Value[data_outlier$all.stats$Outlier]
max_DBH <- ifelse(length(outliers) == 0, max(data_temp$DBH), min(outliers) - 1)

# Set parameters 
data <- Trees_data %>% 
  filter(!CrwnCl %in% c("DD", "BBD", "CUS"))
query <- "Trees DBH Max" 
query_message <- paste0("Tag ", data$TagNo, ". ", "DBH")
values_data <- data$DBH
values_valid <- max_DBH
values_check <- values_data <= values_valid

# Identify errors
errors_Trees_DBH_Max <- qaqc(data, query, query_message, values_check)
```

#### Combine DBH Errors

```{r}
# Combine
errors_Trees_DBH <- unique(rbind(errors_Trees_DBH_Min, errors_Trees_DBH_Max))

remove(errors_Trees_DBH_Min, errors_Trees_DBH_Max)
```

### Trees DD

[Problem]{.underline}: DBH, height, and or crown base height entered for trees that are no longer standing.

[Procedure:]{.underline}

-   Filter for CrwnCl = BBD, CUS, or DD. Check that DBH, Ht, [and]{.underline} LiCrBHt are blank

```{r}
# Set parameters 
data <- Trees_data %>% 
  filter(CrwnCl %in% c("DD", "BBD", "CUS"))
data$DBH[is.na(data$DBH)] <- ""
query <- "Trees DD DBH" 
query_message <- paste0("Tag ", data$TagNo, ". ", "Crown Class = DD. DBH")
values_data <- data$DBH
values_valid <- ""
values_check <- values_data == values_valid

# Identify errors
errors_Trees_DD_DBH <- qaqc(data, query, query_message, values_check)
```

```{r}
# Set parameters 
data <- Trees_data %>% 
  filter(CrwnCl %in% c("DD", "BBD", "CUS"))
data$Ht[is.na(data$Ht)] <- ""
query <- "Trees DD Ht" 
query_message <- paste0("Tag ", data$TagNo, ". ", "Crown Class = DD. Height")
values_data <- data$Ht
values_valid <- ""
values_check <- values_data == values_valid

# Identify errors
errors_Trees_DD_Ht <- qaqc(data, query, query_message, values_check)
```

```{r}
# Set parameters 
data <- Trees_data %>% 
  filter(CrwnCl %in% c("DD", "BBD", "CUS"))
data$LiCrBHt[is.na(data$LiCrBHt)] <- ""
query <- "Trees DD CBH" 
query_message <- paste0("Tag ", data$TagNo, ". ", "Crown Class = DD. Live Crown Base Height")
values_data <- data$LiCrBHt
values_valid <- ""
values_check <- values_data == values_valid

# Identify errors
errors_Trees_DD_LiCrBHt <- qaqc(data, query, query_message, values_check)
```

#### Combine DD Errors

```{r}
# Combine
errors_Trees_DD <- unique(rbind(errors_Trees_DD_DBH, errors_Trees_DD_Ht, errors_Trees_DD_LiCrBHt))

remove(errors_Trees_DD_DBH, errors_Trees_DD_Ht, errors_Trees_DD_LiCrBHt)
```

### Trees Duplicates

[Problem]{.underline}: Duplicate tree tag numbers entered for a plot visit.

[Procedure:]{.underline}

-   Check for duplicate tree tags across Date, MacroPlot.Name, SubFrac [and]{.underline} TagNo.

```{r}
# Check for tag duplication and store results in new column
data_temp <- Trees_data %>% 
  get_dupes(Date, MacroPlot.Name, SubFrac, TagNo)

# Set parameters 
data <- merge(Trees_data, data_temp, all.x = T)
data$dupe_count[is.na(data$dupe_count)] <- 0
query <- "Trees Duplicates" 
query_message <- paste0("Tag ", data$TagNo, ". ", "Duplicates")
values_data <- data$dupe_count
values_valid <- 0
values_check <- values_data == values_valid

# Identify errors
errors_Trees_Duplicate <- qaqc(data, query, query_message, values_check)
```

### Trees Frac

[Problem:]{.underline} Incorrect subplot fraction entered for trees.

[Note:]{.underline} In some cases pole SubFrac will differ from 0.5 if a smaller area was sampled in a particular year. Check yearly procedures to confirm correct values.

[Procedure:]{.underline}

-   If DBH = overstory, then check that SubFrac = 1

```{r}
# Set parameters 
data <- Trees_data %>% 
   filter(DBH > 15.0)
query <- "Trees Frac Overstory" 
query_message <- paste0("Tag ", data$TagNo, ". ", "DBH = overstory. Subplot Fraction")
values_data <- data$SubFrac
values_valid <- 1
values_check <- values_data == values_valid

# Identify errors
errors_Trees_Frac_Overstory <- qaqc(data, query, query_message, values_check)
```

-   If DBH = pole, then check that SubFrac = 0.5

```{r}
# Set parameters 
data <- Trees_data %>% 
  filter(DBH <= 15.0)
query <- "Trees Frac Pole" 
query_message <- paste0("DBH = pole. Subplot Fraction")
values_data <- data$SubFrac
values_valid <- 0.5
values_check <- values_data == values_valid

# Identify errors
errors_Trees_Frac_Pole <- qaqc(data, query, query_message, values_check)
```

#### Combine Frac Errors

```{r}
# Combine
errors_Trees_Frac <- unique(rbind(errors_Trees_Frac_Overstory, errors_Trees_Frac_Pole))

remove(errors_Trees_Frac_Overstory, errors_Trees_Frac_Pole)
```

### Trees Height

#### Trees Height Standing

[Problem:]{.underline} Height not recorded. Standing trees should have height values.

[Procedure:]{.underline}

-   Filter for standing trees. Check that Ht exists.

```{r}
# Set parameters 
data <- Trees_data %>% 
   filter(!CrwnCl %in% c("DD", "BBD", "CUS"))
data$Ht[is.na(data$Ht)] <- ""
query <- "Trees Height Standing" 
query_message <- paste0("Standing tree. Height")
values_data <- data$Ht
values_valid <- ""
values_check <- values_data != values_valid

# Identify errors
errors_Trees_Height_Standing <- qaqc(data, query, query_message, values_check)
```

#### Trees Height Overstory

[Problem:]{.underline} Incorrect values entered for height. Overstory trees should have reasonable height values.

[Procedure:]{.underline}

-   Filter for Overstory trees. Check that Ht is not excessively large.

```{r}
# Perform Rosner's Test for outliers using all values
data_temp <- Trees_all %>%
  filter(!is.na(Ht), DBH > 15.0)
data_outlier <- rosnerTest(data_temp$Ht)
outliers <- data_outlier$all.stats$Value[data_outlier$all.stats$Outlier]
max_Ht <- ifelse(length(outliers) == 0, max(data_temp$Ht), min(outliers) - 1)

# Set parameters 
data <- Trees_data %>% 
   filter(DBH > 15.0)
query <- "Trees Height Overstory" 
query_message <- paste0("DBH = overstory. Height")
values_data <- data$Ht
values_valid <- max_Ht
values_check <- values_data <= values_valid

# Identify errors
errors_Trees_Height_Overstory <- qaqc(data, query, query_message, values_check)
```

#### Trees Height Pole

[Problem:]{.underline} Incorrect values entered for height. Pole trees should correspond to an established height class.

[Procedure:]{.underline}

-   Filter for Pole trees. Check that Ht = 0.6, 1, 2, 3, 4, 5, 6, 7, 8, 9, or 10 or blank.

```{r}
# Set parameters 
data <- Trees_data %>% 
  filter(DBH <= 15.0)
query <- "Trees Height Pole" 
query_message <- paste0("Tag ", data$TagNo, ". ", "DBH = pole. Height")
values_data <- data$Ht
values_valid <- c("", 0.6, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
values_check <- values_data %in% values_valid

# Identify errors
errors_Trees_Height_Pole <- qaqc(data, query, query_message, values_check)
```

#### Combine Height Errors

```{r}
# Combine
errors_Trees_Height <- unique(rbind(errors_Trees_Height_Standing, errors_Trees_Height_Overstory, errors_Trees_Height_Pole))

remove(errors_Trees_Height_Standing, errors_Trees_Height_Overstory, errors_Trees_Height_Pole)
```

### Trees Life Form

[Problem:]{.underline} Species entered that are not trees.

[Procedure:]{.underline}

-   Check that Preferred Lifeform = Tree

```{r}
# Set parameters 
data <- Trees_data
query <- "Trees Life Form" 
query_message <- paste0("Tag ", data$TagNo, ". ", "Life Form")
values_data <- data$Preferred_Lifeform
values_valid <- "Tree"
values_check <- values_data == values_valid

# Identify errors
errors_Trees_LifeForm <- qaqc(data, query, query_message, values_check)
```

### Trees Non-Post Severity

[Problem]{.underline}: Scorch height, scorch %, and/or char height are entered in sample events other than immediate post for RAP plots. These values should only be collected at immediate post reads.

[Procedure:]{.underline}

-   Filter to exclude all POST reads (01Post, 02Post, etc). Check that CharHt = blank, ScorchHt = blank, [and]{.underline} CrScPct = blank (i.e. no records should appear in the query)

```{r}
# Set parameters 
data <- Trees_data %>% 
  filter(!Monitoring.Status %in% c("01Post", "01PostB", "02Post", "02PostB", "03Post", "04Post"))
data$CharHt[is.na(data$CharHt)] <- ""
query <- "Trees Non-Post Severity CharHt" 
query_message <- paste0("Tag ", data$TagNo, ". ", "Non-post read. Char Height")
values_data <- data$CharHt
values_valid <- ""
values_check <- values_data == values_valid

# Identify errors
errors_Trees_NonPost_Severity_CharHt <- qaqc(data, query, query_message, values_check)
```

```{r}
# Set parameters 
data <- Trees_data %>% 
  filter(!Monitoring.Status %in% c("01Post", "01PostB", "02Post", "02PostB", "03Post", "04Post"))
data$ScorchHt[is.na(data$ScorchHt)] <- ""
query <- "Trees Non-Post Severity ScorchHt" 
query_message <- paste0("Tag ", data$TagNo, ". ", "Non-post read. Scorch Height")
values_data <- data$ScorchHt
values_valid <- ""
values_check <- values_data == values_valid

# Identify errors
errors_Trees_NonPost_Severity_ScorchHt <- qaqc(data, query, query_message, values_check)
```

```{r}
# Set parameters 
data <- Trees_data %>% 
  filter(!Monitoring.Status %in% c("01Post", "01PostB", "02Post", "02PostB", "03Post", "04Post"))
data$CrScPct[is.na(data$CrScPct)] <- ""
query <- "Trees Non-Post Severity CrScPct" 
query_message <- paste0("Tag ", data$TagNo, ". ", "Non-post read. Crown Scorch Percent")
values_data <- data$CrScPct
values_valid <- ""
values_check <- values_data == values_valid

# Identify errors
errors_Trees_NonPost_Severity_CrScPct <- qaqc(data, query, query_message, values_check)
```

#### Combine Non-Post Severity Errors

```{r}
# Combine
errors_Trees_NonPost_Severity <- unique(rbind(errors_Trees_NonPost_Severity_CharHt, errors_Trees_NonPost_Severity_ScorchHt, errors_Trees_NonPost_Severity_CrScPct))

remove(errors_Trees_NonPost_Severity_CharHt, errors_Trees_NonPost_Severity_ScorchHt, errors_Trees_NonPost_Severity_CrScPct)
```

### Trees Post

#### Trees Post Char

[Problem]{.underline}: Char height missing or excessively large for standing trees during the immediate post-fire sample events in RAP plots. Char height entered for trees that are no longer standing.

[Note]{.underline}: Post-burn measurements were not collected on pole-sized trees 1990-2002.

[Procedure:]{.underline}

-   DD trees. Filter to include all POST reads (01Post, 02Post, etc). Filter for DD crown classes (DD, BBD, and CUS). Check that CharHt = blank.

```{r}
# Set parameters 
data <- Trees_data %>% 
  filter(Monitoring.Status %in% c("01Post", "01PostB", "02Post", "02PostB", "03Post", "04Post"),
         CrwnCl %in% c("DD", "BBD", "CUS"))
data$CharHt[is.na(data$CharHt)] <- ""
query <- "Trees Post Char DD" 
query_message <- paste0("Tag ", data$TagNo, ". ", "Crown Class = DD. Char Height")
values_data <- data$CharHt
values_valid <- ""
values_check <- values_data == values_valid

# Identify errors
errors_Trees_Post_Char_DD <- qaqc(data, query, query_message, values_check)
```

-   Standing trees. Filter to include all POST reads (01Post, 02Post, etc). Filter to exclude DD crown classes (DD, BBD, and CUS). Check that CharHt is [not]{.underline} blank.

```{r}
# Set parameters 
data <- Trees_data %>% 
  filter(Monitoring.Status %in% c("01Post", "01PostB", "02Post", "02PostB", "03Post", "04Post"),
         !CrwnCl %in% c("DD", "BBD", "CUS"))
data$CharHt[is.na(data$CharHt)] <- ""
query <- "Trees Post Char Standing" 
query_message <- paste0("Tag ", data$TagNo, ". ", "Standing tree. Char Height")
values_data <- data$CharHt
values_valid <- ""
values_check <- values_data != values_valid

# Identify errors
errors_Trees_Post_Char_Standing <- qaqc(data, query, query_message, values_check)
```

-   Max char. Filter to include all POST reads (01Post, 02Post, etc). Check that CharHt is not excessively high.

```{r}
# Perform Rosner's Test for outliers using all values
data_temp <- Trees_all %>%
  filter(Monitoring.Status %in% c("01Post", "01PostB", "02Post", "02PostB", "03Post", "04Post"),
         !is.na(CharHt))
data_outlier <- rosnerTest(data_temp$CharHt)
outliers <- data_outlier$all.stats$Value[data_outlier$all.stats$Outlier]
max_Char <- ifelse(length(outliers) == 0, max(data_temp$CharHt), min(outliers) - 1)

# Set parameters 
data <- Trees_data %>% 
  filter(Monitoring.Status %in% c("01Post", "01PostB", "02Post", "02PostB", "03Post", "04Post"),
         !is.na(CharHt))
query <- "Trees Post Char Max" 
query_message <- paste0("Tag ", data$TagNo, ". ", "Char Height")
values_data <- data$CharHt
values_valid <- max_Char
values_check <- values_data <= values_valid

# Identify errors
errors_Trees_Post_Char_Max <- qaqc(data, query, query_message, values_check)
```

#### Trees Post ScorchHt

[Problem]{.underline}: Scorch height missing or excessively large for live trees during the immediate post-fire sample events in RAP plots. Scorch height entered for trees that are no longer standing or are broken.

[Note]{.underline}: Post-burn measurements were not collected on pole-sized trees 1990-2002.

[Procedure:]{.underline}

-   DD Trees. Filter to include all POST reads (01Post, 02Post, etc). Filter for DD crown classes (DD, BBD, and CUS). Check that ScorchHt = blank.

```{r}
# Set parameters 
data <- Trees_data %>% 
  filter(Monitoring.Status %in% c("01Post", "01PostB", "02Post", "02PostB", "03Post", "04Post"),
         CrwnCl %in% c("DD", "BBD", "CUS"))
data$ScorchHt[is.na(data$ScorchHt)] <- ""
query <- "Trees Post Scorch DD" 
query_message <- paste0("Tag ", data$TagNo, ". ", "Crown Class = DD. Scorch Height")
values_data <- data$ScorchHt
values_valid <- ""
values_check <- values_data == values_valid

# Identify errors
errors_Trees_Post_Scorch_DD <- qaqc(data, query, query_message, values_check)
```

-   Standing Dead Trees. Filter to include all POST reads (01Post, 02Post, etc). Filter to exclude DD crown classes (DD, BBD, and CUS). Filter for Status = D. Check that ScorchHt = blank. If ScorchHt is not blank, check that ScorchHt = Ht (100% scorch)

```{r}
# Set parameters 
data <- Trees_data %>% 
  filter(Monitoring.Status %in% c("01Post", "01PostB", "02Post", "02PostB", "03Post", "04Post"),
         !CrwnCl %in% c("DD", "BBD", "CUS"),
         Status == "D",
         ScorchHt != Ht)
data$ScorchHt[is.na(data$ScorchHt)] <- ""
query <- "Trees Post Scorch Dead"
query_message <- paste0("Tag ", data$TagNo, ". ", "Status = D. Standing tree. Scorch Height")
values_data <- data$ScorchHt
values_valid <- ""
values_check <- values_data == values_valid

# Identify errors
errors_Trees_Post_Scorch_Dead <- qaqc(data, query, query_message, values_check)
```

-   Live trees. Filter to include all POST reads (01Post, 02Post, etc). Filter for Status = L. Check that ScorchHt is not blank or excessively high.

```{r}
# Perform Rosner's Test for outliers using all values
data_temp <- Trees_all %>%
  filter(Monitoring.Status %in% c("01Post", "01PostB", "02Post", "02PostB", "03Post", "04Post"),
         !is.na(ScorchHt))
data_outlier <- rosnerTest(data_temp$ScorchHt)
outliers <- data_outlier$all.stats$Value[data_outlier$all.stats$Outlier]
max_Scorch <- ifelse(length(outliers) == 0, max(data_temp$ScorchHt), min(outliers) - 1)

# Set parameters 
data <- Trees_data %>% 
  filter(Monitoring.Status %in% c("01Post", "01PostB", "02Post", "02PostB", "03Post", "04Post"),
         Status == "L")
query <- "Trees Post Scorch Live" 
query_message <- paste0("Tag ", data$TagNo, ". ", "Status = L. Scorch Height")
values_data <- data$ScorchHt
values_valid <- max_Scorch
values_check <- values_data <= values_valid

# Identify errors
errors_Trees_Post_Scorch_Live <- qaqc(data, query, query_message, values_check)
```

#### Trees Post Scorch%

[Problem]{.underline}: Scorch % missing or excessively large for live trees during the immediate post-fire sample events in RAP plots. Scorch % entered incorrectly for trees that are no longer standing.

[Note]{.underline}: Post-burn measurements were not collected on pole-sized trees 1990-2002.

[Procedure:]{.underline}

-   DD Trees. Filter to include all POST reads (01Post, 02Post, etc). Filter for DD crown classes (DD, BBD, and CUS). Check that CrScPct = blank.

-   Check that all rows with CrwnCl = DD have CrScPct = blank or 100. (RS?)

```{r}
# Set parameters 
data <- Trees_data %>% 
  filter(Monitoring.Status %in% c("01Post", "01PostB", "02Post", "02PostB", "03Post", "04Post"),
         CrwnCl %in% c("DD", "BBD", "CUS"))
data$CrScPct[is.na(data$CrScPct)] <- ""
query <- "Trees Post Scorch% DD" 
query_message <- paste0("Tag ", data$TagNo, ". ", "Crown Class = DD. Scorch Percent")
values_data <- data$CrScPct
values_valid <- ""
values_check <- values_data == values_valid

# Identify errors
errors_Trees_Post_ScorchPct_DD <- qaqc(data, query, query_message, values_check)
```

-   Standing Dead Trees. Filter to include all POST reads (01Post, 02Post, etc). Filter to exclude DD crown classes (DD, BBD, and CUS). Filter for Status = D. Check that CrScPct = blank or 100.

```{r}
# Set parameters 
data <- Trees_data %>% 
  filter(Monitoring.Status %in% c("01Post", "01PostB", "02Post", "02PostB", "03Post", "04Post"),
         !CrwnCl %in% c("DD", "BBD", "CUS"),
         Status == "D")
data$CrScPct[is.na(data$CrScPct)] <- ""
query <- "Trees Post Scorch% Dead"
query_message <- paste0("Tag ", data$TagNo, ". ", "Status = D. Standing tree. Scorch Percent")
values_data <- data$CrScPct
values_valid <- c("", 100)
values_check <- values_data %in% values_valid

# Identify errors
errors_Trees_Post_ScorchPct_Dead <- qaqc(data, query, query_message, values_check)
```

-   Live trees. Filter to include all POST reads (01Post, 02Post, etc). Filter for Status = L. Check that CrScPct is not blank. Check that CrScPct ≤ 100.

```{r}
# Set parameters 
data <- Trees_data %>% 
  filter(Monitoring.Status %in% c("01Post", "01PostB", "02Post", "02PostB", "03Post", "04Post"),
         Status == "L")
query <- "Trees Post Scorch% Live" 
query_message <- paste0("Tag ", data$TagNo, ". ", "Status = L. Scorch Percent")
values_data <- data$CrScPct
values_valid <- max(100)
values_check <- values_data <= values_valid

# Identify errors
errors_Trees_Post_ScorchPct_Live <- qaqc(data, query, query_message, values_check)
```

#### Combine Post Severity Errors

```{r}
# Combine
errors_Trees_Post_Severity <- unique(rbind(errors_Trees_Post_Char_DD, errors_Trees_Post_Char_Standing, errors_Trees_Post_Char_Max, errors_Trees_Post_Scorch_DD, errors_Trees_Post_Scorch_Dead, errors_Trees_Post_Scorch_Live, errors_Trees_Post_ScorchPct_DD, errors_Trees_Post_ScorchPct_Dead, errors_Trees_Post_ScorchPct_Live))

remove(errors_Trees_Post_Char_DD, errors_Trees_Post_Char_Standing, errors_Trees_Post_Char_Max, errors_Trees_Post_Scorch_DD, errors_Trees_Post_Scorch_Dead, errors_Trees_Post_Scorch_Live, errors_Trees_Post_ScorchPct_DD, errors_Trees_Post_ScorchPct_Dead, errors_Trees_Post_ScorchPct_Live)
```

### Trees Status

[Problem:]{.underline} Species do not have an entry for status or have an entry that we don’t use.

[Procedure:]{.underline}

-   Sort by Status. Check that Status = L or D

```{r}
# Set parameters 
data <- Trees_data
query <- "Trees Status" 
query_message <- paste0("Tag ", data$TagNo, ". ", "Status")
values_data <- data$Status
values_valid <- c("L", "D")
values_check <- values_data %in% values_valid

# Identify errors
errors_Trees_Status <- qaqc(data, query, query_message, values_check)
```

### Trees UV

[Problem]{.underline}: X present in the UV columns signifying respective data (DBH, Ht, or LiCrBHT) weren’t assessed.

[Procedure]{.underline}:

-   Check that UV(1, 2, [or]{.underline} 3) is blank for all plots

```{r}
# # Set parameters 
# data <- Trees_data
# data$UV1[is.na(data$UV1)] <- ""
# query <- "Trees UV1" 
# query_message <- paste0("Tag ", data$TagNo, ". ", "User Variable 1")
# values_data <- data$UV1
# values_valid <- ""
# values_check <- values_data == values_valid
# 
# # Identify errors
# errors_Trees_UV1 <- qaqc(data, query, query_message, values_check)
```

```{r}
# Set parameters 
data <- Trees_data
data$UV2[is.na(data$UV2)] <- ""
query <- "Trees UV2" 
query_message <- paste0("Tag ", data$TagNo, ". ", "User Variable 2")
values_data <- data$UV2
values_valid <- ""
values_check <- values_data == values_valid

# Identify errors
errors_Trees_UV2 <- qaqc(data, query, query_message, values_check)
```

```{r}
# Set parameters 
data <- Trees_data
data$UV3[is.na(data$UV3)] <- ""
query <- "Trees UV3" 
query_message <- paste0("Tag ", data$TagNo, ". ", "User Variable 3")
values_data <- data$UV3
values_valid <- ""
values_check <- values_data == values_valid

# Identify errors
errors_Trees_UV3 <- qaqc(data, query, query_message, values_check)
```

#### Combine UV Errors

```{r}
# Combine
errors_Trees_UV <- unique(rbind(errors_Trees_UV2, errors_Trees_UV3))

remove(errors_Trees_UV2, errors_Trees_UV3)
```

### Trees Errors

```{r}
# errors_Trees <- unique(rbind(errors_Trees_CrwnCl, errors_Trees_DamCd, errors_Trees_DBH, errors_Trees_DD, errors_Trees_CBH, errors_Trees_Duplicate, errors_Trees_Frac, errors_Trees_Header, errors_Trees_Height, errors_Trees_Hits, errors_Trees_NonPost_Severity, errors_Trees_Post_Severity, errors_Trees_Status, errors_Trees_LifeForm, errors_Trees_UV))

errors_Trees <- rbind(errors_Trees_CrwnCl, errors_blank, errors_Trees_DamCd, errors_blank, errors_Trees_DBH, errors_blank, errors_Trees_DD, errors_blank, errors_Trees_CBH, errors_blank, errors_Trees_Duplicate, errors_blank, errors_Trees_Frac, errors_blank, errors_Trees_Header, errors_blank, errors_Trees_Height, errors_blank, errors_Trees_Hits, errors_blank, errors_Trees_NonPost_Severity, errors_blank, errors_Trees_Post_Severity, errors_blank, errors_Trees_Status, errors_blank, errors_Trees_LifeForm, errors_blank, errors_Trees_UV)

remove(errors_Trees_Header, errors_Trees_CrwnCl, errors_Trees_DamCd, errors_Trees_DBH, errors_Trees_CBH, errors_Trees_DD, errors_Trees_Duplicate, errors_Trees_Frac, errors_Trees_Height, errors_Trees_Hits, errors_Trees_NonPost_Severity, errors_Trees_Post_Severity, errors_Trees_Status, errors_Trees_LifeForm, errors_Trees_UV)
```

```{r}
# Table of results for quick check
#kable(errors_Trees, "pipe")

# Save as CSV or XLSX
path_errors
#write.csv(errors_Trees, paste0(path_errors, "errors_GRCA_RAP_Trees.csv"), quote=FALSE, row.names = FALSE, na = "")
#write_xlsx(errors_Trees, paste0(path_errors, "errors_GRCA_RAP_Trees.xlsx"))
```

# PROTOCOL - SEEDLINGS

This code conducts quality control checks on seedling data within the "Density - Quadrats (metric)" data set.

It checks for errors in: headers, seedling counts, subplot fractions, heights, status, and life form.

### Seedlings Header

[Problem:]{.underline} Incorrect header information entered for RAP plots.

[Procedure:]{.underline}

-   Check that Area = 314

```{r}
# Set parameters 
data <- Seedlings_header
query <- "Dens Quad Header Area" 
query_message <- paste0("Area")
values_data <- data$Area
values_valid <- 314
values_check <- values_data == values_valid

# Identify errors
errors_Seedlings_Area <- qaqc(data, query, query_message, values_check)
```

-   Check that QuadWid = 314

```{r}
# Set parameters 
data <- Seedlings_header
query <- "Dens Quad Header QuadWid" 
query_message <- paste0("Quad Width")
values_data <- data$QuadWid
values_valid <- 314
values_check <- values_data == values_valid

# Identify errors
errors_Seedlings_QuadWid <- qaqc(data, query, query_message, values_check)
```

-   Check that QuadLen = 1

```{r}
# Set parameters 
data <- Seedlings_header
query <- "Dens Quad Header QuadLen" 
query_message <- paste0("Quad Length")
values_data <- data$QuadLen
values_valid <- 1
values_check <- values_data == values_valid

# Identify errors
errors_Seedlings_QuadLen <- qaqc(data, query, query_message, values_check)
```

-   Check that NumTran = 1

```{r}
# Set parameters 
data <- Seedlings_header
query <- "Dens Quad Header NumTran" 
query_message <- paste0("Number of Transects")
values_data <- data$NumTran
values_valid <- 1
values_check <- values_data == values_valid

# Identify errors
errors_Seedlings_NumTran <- qaqc(data, query, query_message, values_check)
```

-   Check that NumQuadTran = 1

```{r}
# Set parameters 
data <- Seedlings_header
query <- "Dens Quad Header NumQuadTran" 
query_message <- paste0("Number Quad Transects")
values_data <- data$NumQuadTran
values_valid <- 1
values_check <- values_data == values_valid

# Identify errors
errors_Seedlings_NumQuadTran <- qaqc(data, query, query_message, values_check)
```

#### Combine Header Errors

```{r}
errors_Seedlings_Header <- unique(rbind(errors_Seedlings_Area, errors_Seedlings_QuadWid, errors_Seedlings_QuadLen, errors_Seedlings_NumTran, errors_Seedlings_NumQuadTran))

remove(errors_Seedlings_Area, errors_Seedlings_QuadWid, errors_Seedlings_QuadLen, errors_Seedlings_NumTran, errors_Seedlings_NumQuadTran)
```

### Seedlings Hits

[Problem:]{.underline} Extra or missing data points in FMH plots. Plots with no seedlings should be verified.

[Procedure:]{.underline}

-   Group by Macroplot and Date. Calculate number of hits per plot. Check that sum_hits \> 0

```{r}
# Filter NA values. Add number of hits and store in new column
data_temp1 <- Seedlings_data %>%
  group_by(MacroPlot.Name, Date) %>% 
  dplyr::summarize("sum_hits" = n())

data_temp2 <- Seedlings_header %>% 
  group_by(MacroPlot.Name, Date) %>% 
  dplyr::summarise()

data_temp <- merge(data_temp1, data_temp2, by = c("MacroPlot.Name","Date"), all = TRUE)
data_temp$sum_hits[is.na(data_temp$sum_hits)] <- 0
remove(data_temp1, data_temp2)

# Set parameters 
data <- merge(Seedlings_data, data_temp, by = c("MacroPlot.Name", "Date"), all = T)
query <- "Seedlings Hits" 
query_message <- "Seedlings" 
values_data <- data$sum_hits
values_valid <- 0
values_check <- values_data > values_valid

# Identify errors
errors_Seedlings_Hits <- qaqc(data, query, query_message, values_check)
```

### Seedlings Count

[Problem:]{.underline} Seedling count values missing, zero, or excessively high (\>100 is possible, but should be verified).

[Procedure:]{.underline}

-   Check that Count is not blank or 0

```{r}
# Set parameters 
data <- Seedlings_data
query <- "Dens Quad Count Min" 
query_message <- paste0("Count")
values_data <- data$Count
values_valid <- 1
values_check <- values_data >= values_valid

# Identify errors
errors_Seedlings_Count_Min <- qaqc(data, query, query_message, values_check)
```

-   Check that Count is not excessively high

```{r}
# Perform Rosner's Test for outliers using all values
data_temp <- Seedlings_all %>%
  filter(!is.na(Count))
data_outlier <- rosnerTest(data_temp$Count)
outliers <- data_outlier$all.stats$Value[data_outlier$all.stats$Outlier]
max_SeedCount <- ifelse(length(outliers) == 0, max(data_temp$Count), min(outliers) - 1)

# Set parameters 
data <- Seedlings_data
query <- "Dens Quad Count Max" 
query_message <- paste0("Count")
values_data <- data$Count
values_valid <- max_SeedCount
values_check <- values_data <= values_valid

# Identify errors
errors_Seedlings_Count_Max <- qaqc(data, query, query_message, values_check)
```

#### Combine Count Errors

```{r}
errors_Seedlings_Count <- unique(rbind(errors_Seedlings_Count_Min, errors_Seedlings_Count_Max))

remove(errors_Seedlings_Count_Min, errors_Seedlings_Count_Max)
```

### Seedlings Frac

[Problem:]{.underline} Incorrect subplot fraction entered or subplot fraction missing for RAP plots.

[Procedure:]{.underline}

-   Check that SubFrac = 1 or 0.25

```{r}
# Set parameters 
data <- Seedlings_data
query <- "Dens Quad Frac" 
query_message <- paste0("Subplot Fraction")
values_data <- data$SubFrac
values_valid <- c(0.25, 1)
values_check <- values_data %in% values_valid

# Identify errors
errors_Seedlings_Frac <- qaqc(data, query, query_message, values_check)
```

### Seedlings Height

[Problem:]{.underline} Incorrect values entered for height or height values missing.

[Note:]{.underline} Height will be blank for all species in the following RAP projects: Fawn Spring, Hwy 67, Spring Canyon, Thompson, Tipover

[Note:]{.underline} Disregard entries with blank height values when “species symbol” and “height” are also blank. Trees with no height value are pole trees instead of seedlings

[Procedure:]{.underline}

-   Sort by Height. Check that Height = 0.15, 0.3, 0.6, 1, 2, 3, 4, 5, 6, 7, 8, 9, or 10

```{r}
# Set parameters 
data <- Seedlings_data %>% 
  filter(!MacroPlot.Purpose %in% c("Fawn Spring", "Hwy 67", "Spring Canyon", "Thompson", "Tipover"))
query <- "Dens Quad Height" 
query_message <- paste0("SubFrac = ", data$SubFrac, ". ", "Species = ", data$Species.Symbol, ". ", "Height")
values_data <- data$Height
values_valid <- c(0.15, 0.3, 0.6, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
values_check <- values_data %in% values_valid

# Identify errors
errors_Seedlings_Height <- qaqc(data, query, query_message, values_check)
```

### Seedlings Status

[Problem:]{.underline} Species do not have an entry for status or have an entry that we don’t use.

[Procedure:]{.underline}

-   Sort by Status. Check that Status = L

```{r}
# Set parameters 
data <- Seedlings_data
query <- "Dens Quad Status" 
query_message <- paste0("Species ", data$Species.Symbol, ". ", "Status")
values_data <- data$Status
values_valid <- c("L")
values_check <- values_data %in% values_valid

# Identify errors
errors_Seedlings_Status <- qaqc(data, query, query_message, values_check)
```

### Seedlings Life Form

[Problem:]{.underline} Species entered that are not trees.

[Procedure:]{.underline}

-   Check that Preferred Lifeform = Tree

```{r}
# Set parameters 
data <- Seedlings_data
query <- "Dens Quad Tree" 
query_message <- paste0("Life Form")
values_data <- data$Preferred_Lifeform
values_valid <- "Tree"
values_check <- values_data == values_valid

# Identify errors
errors_Seedlings_LifeForm <- qaqc(data, query, query_message, values_check)
```

### Seedlings Values

[Problem:]{.underline} Incorrect values entered for transect and quadrat.

[Procedure:]{.underline}

-   Check that Transect = 1

```{r}
# Set parameters 
data <- Seedlings_data
query <- "Dens Quad Values Transect" 
query_message <- paste0("Transect")
values_data <- data$Transect
values_valid <- 1
values_check <- values_data == values_valid

# Identify errors
errors_Seedlings_Transect <- qaqc(data, query, query_message, values_check)
```

-   Check that Quadrat = 1

```{r}
# Set parameters 
data <- Seedlings_data
query <- "Dens Quad Values Quadrat" 
query_message <- paste0("Quadrat")
values_data <- data$Quadrat
values_valid <- 1
values_check <- values_data == values_valid

# Identify errors
errors_Seedlings_Quadrat <- qaqc(data, query, query_message, values_check)
```

#### Combine Values Errors

```{r}
errors_Seedlings_Values <- unique(rbind(errors_Seedlings_Transect, errors_Seedlings_Quadrat))

remove(errors_Seedlings_Transect, errors_Seedlings_Quadrat)
```

### Seedlings Errors

```{r}
errors_Seedlings <- rbind(errors_Seedlings_Count, errors_blank, errors_Seedlings_Frac, errors_blank, errors_Seedlings_Header, errors_blank, errors_Seedlings_Height, errors_blank, errors_Seedlings_Hits, errors_blank, errors_Seedlings_Status, errors_blank, errors_Seedlings_LifeForm, errors_blank, errors_Seedlings_Values)

remove(errors_Seedlings_Count, errors_Seedlings_Frac, errors_Seedlings_Header, errors_Seedlings_Height, errors_Seedlings_Hits, errors_Seedlings_Status, errors_Seedlings_LifeForm, errors_Seedlings_Values)
```

```{r}
# Table of results for quick check
#kable(errors_Seedlings, "pipe")

# Save as CSV or XLSX
path_errors
#write.csv(errors_Seedlings, paste0(path_errors, "errors_GRCA_RAP_Seedlings.csv"), quote=FALSE, row.names = FALSE, na = "")
#write_xlsx(errors_Seedlings, paste0(path_errors, "errors_GRCA_RAP_Seedlings.xlsx"))
```

# PROTOCOL - HERBS OBSERVED

This code conducts quality control checks on observed herbaceous data within the "Cover - Species Composition (metric)" data set.

It checks for errors in: cover, species, and status.

### HerbsObs Hits

[Problem:]{.underline} Extra or missing data points in FMH plots. Plots with no observed herbs should be verified.

[Procedure:]{.underline}

-   Group by Macroplot and Date. Calculate number of hits per plot. Check that sum_hits \> 0

```{r}
# Filter NA values. Add number of hits and store in new column
data_temp1 <- HerbsObs_data %>%
  group_by(MacroPlot.Name, Date) %>% 
  dplyr::summarize("sum_hits" = n())

data_temp2 <- HerbsObs_header %>% 
  group_by(MacroPlot.Name, Date) %>% 
  dplyr::summarise()

data_temp <- merge(data_temp1, data_temp2, by = c("MacroPlot.Name","Date"), all = TRUE)
data_temp$sum_hits[is.na(data_temp$sum_hits)] <- 0
remove(data_temp1, data_temp2)

# Set parameters 
data <- merge(HerbsObs_data, data_temp, by = c("MacroPlot.Name", "Date"), all = T)
query <- "Cvr SpComp Hits" 
query_message <- "Species" 
values_data <- data$sum_hits
values_valid <- 0
values_check <- values_data > values_valid

# Identify errors
errors_HerbsObs_Hits <- qaqc(data, query, query_message, values_check)
```

### HerbsObs Cover

[Problem:]{.underline} Species do not have an entry for cover or have an entry that we don’t use in RAP plots.

[Procedure:]{.underline}

-   Filter for the appropriate project units (Tusayan Pueblo (Thinning) excluded).

-   Check that Cover = 2.5, 15, 37.5, 62.5, 85, or 97.5

```{r}
# Set parameters
data <- HerbsObs_data %>% 
  filter(MacroPlot.Purpose != "Tusayan Pueblo (Thinning)")
query <- "Cvr SpComp Cvr"
query_message <- paste0("Cover")
values_data <- data$Cover
values_valid <- c(2.5, 15, 37.5, 62.5, 85, 97.5)
values_check <- values_data %in% values_valid

# Identify errors
errors_HerbsObs_Cover_1 <- qaqc(data, query, query_message, values_check)
```

-   Filter for the appropriate project units (Tusayan Pueblo (Thinning) only).

-   Check that Cover = 0, 2.5, 15, 37.5, 62.5, 85, or 97.5

```{r}
# Set parameters
data <- HerbsObs_data %>% 
  filter(MacroPlot.Purpose == "Tusayan Pueblo (Thinning)")
query <- "Cvr SpComp Cvr"
query_message <- paste0("Cover")
values_data <- data$Cover
values_valid <- c(0, 2.5, 15, 37.5, 62.5, 85, 97.5)
values_check <- values_data %in% values_valid

# Identify errors
errors_HerbsObs_Cover_2 <- qaqc(data, query, query_message, values_check)
```

#### Combine Cover Errors

```{r}
# Combine
errors_HerbsObs_Cover <- unique(rbind(errors_HerbsObs_Cover_1, errors_HerbsObs_Cover_2))

remove(errors_HerbsObs_Cover_1, errors_HerbsObs_Cover_2)
```

### HerbsObs Species

[Problem:]{.underline} Species entered in RAP plots that shouldn’t be documented.

[Procedure:]{.underline}

-   Filter for the appropriate project units (Tusayan Pueblo (Thinning) excluded). Filter to exclude generic species codes (e.g. GXXX, BRXX), HERBS, and SHRUBS.

-   Check that Native Species = False

```{r}
data_temp <- as.data.frame(grepl("XX", HerbsObs_data$Species.Symbol, fixed = TRUE))
names(data_temp)[1] <- "GenericSpecies"

# Set parameters
data <- cbind(HerbsObs_data, data_temp) %>% 
  filter(MacroPlot.Purpose != "Tusayan Pueblo (Thinning)",
         GenericSpecies != TRUE,
         !Species.Symbol %in% c("HERBS", "SHRUBS"))
query <- "Cvr SpComp Species"
query_message <- paste0("Native Species")
values_data <- data$Native.Species
values_valid <- "False"
values_check <- values_data == values_valid

# Identify errors
errors_HerbsObs_Species_1 <- qaqc(data, query, query_message, values_check)
```

-   [Note:]{.underline} Multiple native species were intentionally assessed for the Tusayan Pueblo (Thinning) project.

-   Filter for the appropriate project units (Tusayan Pueblo (Thinning) only). Filter to exclude generic species codes (e.g. GXXX, BRXX), HERBS, and SHRUBS. Filter to exclue native species which were intentionally assessed: ARTR, CELE, PUST, and QUGA.

-   Check that Native Species = False

```{r}
data_temp <- as.data.frame(grepl("XX", HerbsObs_data$Species.Symbol, fixed = TRUE))
names(data_temp)[1] <- "GenericSpecies"

# Set parameters
data <- cbind(HerbsObs_data, data_temp) %>% 
  filter(MacroPlot.Purpose == "Tusayan Pueblo (Thinning)",
         GenericSpecies != TRUE,
         !Species.Symbol %in% c("HERBS", "SHRUBS", "ARTR", "CELE", "PUST", "QUGA"))
query <- "Cvr SpComp Species"
query_message <- paste0("Native Species")
values_data <- data$Native.Species
values_valid <- "False"
values_check <- values_data == values_valid

# Identify errors
errors_HerbsObs_Species_2 <- qaqc(data, query, query_message, values_check)
```

#### Combine Species Errors

```{r}
# Combine
errors_HerbsObs_Species <- unique(rbind(errors_HerbsObs_Species_1, errors_HerbsObs_Species_2))

remove(errors_HerbsObs_Species_1, errors_HerbsObs_Species_2)
```

### HerbsObs Status

[Problem:]{.underline} Species do not have an entry for status or have an entry that we don’t use.

[Procedure:]{.underline}

-   Sort by Status. Check that Status = L

```{r}
# Set parameters 
data <- HerbsObs_data
query <- "Cvr SpComp Status" 
query_message <- paste0("Species ", data$Species.Symbol, ". ", "Status")
values_data <- data$Status
values_valid <- c("L")
values_check <- values_data %in% values_valid

# Identify errors
errors_HerbsObs_Status <- qaqc(data, query, query_message, values_check)
```

### HerbsObs Errors

```{r}
errors_HerbsObs <- rbind(errors_HerbsObs_Cover, errors_blank, errors_HerbsObs_Hits, errors_blank, errors_HerbsObs_Species, errors_blank, errors_HerbsObs_Status)

remove(errors_HerbsObs_Cover, errors_HerbsObs_Hits, errors_HerbsObs_Species, errors_HerbsObs_Status)
```

```{r}
# Table of results for quick check
#kable(errors_HerbsObs, "pipe")

# Save as CSV or XLSX
path_errors
#write.csv(errors_HerbsObs, paste0(path_errors, "errors_GRCA_RAP_HerbsObs.csv"), quote=FALSE, row.names = FALSE, na = "")
#write_xlsx(errors_HerbsObs, paste0(path_errors, "errors_GRCA_RAP_HerbsObs.xlsx"))
```

# CROSS PROTOCOL CHECKS

## 1000HR VS FINE SLOPE

This code conducts quality control checks on slope data in the surface fuels coarse woody debris (1000-hr) and fine woody debris datasets. It also checks for overall consistency in slope and azimuth values across years.

```{r}
# # Set parameters 
# data_Fuels1000_slope <- Fuels1000_data %>% 
#   group_by(MacroPlot.Name, Date, Transect, Slope) %>% 
#   summarise("MacroPlot.Name" = unique(MacroPlot.Name), 
#             "Transect" = unique(Transect)) %>% 
#   mutate(Slope_1000 = Slope) %>% 
#   arrange(MacroPlot.Name, Transect) %>% 
#   select(!Slope)
# 
# data_FuelsFine_slope <- FuelsFine_data %>% 
#   group_by(MacroPlot.Name, Date, Transect, Comment, Slope) %>% 
#   summarise("MacroPlot.Name" = unique(MacroPlot.Name), 
#             "Transect" = unique(Transect)) %>% 
#   mutate(Slope_fine = Slope) %>% 
#   arrange(MacroPlot.Name, Transect) %>% 
#   select(!Slope)
# 
# errors_Fuels_slope <- merge(data_Fuels1000_slope, data_FuelsFine_slope, all.y = T) %>% 
#   filter(Slope_fine != Slope_1000) %>% 
#   mutate(SavedQuery = "Fuel Slope",
#          Error = paste("FWD slope", Slope_fine, "!=", "CWD slope", Slope_1000)) %>% 
#   reframe("SavedQuery" = unique(query),
#           "MacroPlot.Name" = unique(MacroPlot.Name), 
#           "Date" = unique(Date), 
#           "Error" = unique(Error),
#           "Comment" = unique(Comment))
# 
# # If no errors, add "No Errors" to existing data frame 
# if (nrow(errors_Fuels_slope) == 0) {   
#     errors_Fuels_slope <- errors_blank_NoError %>%     
#     mutate(SavedQuery = query) 
# } else {   
#     errors_Fuels_slope <- errors_Fuels_slope
# }
```

# CROSS YEAR CHECKS

## Trees Dead to Alive

## Trees Smaller DBH

## Trees Shorter Height

## Trees Shorter CBH

## Trees Changing Tag Numbers

# ALL ERRORS

```{r}
# Save to master error list 
# errors_all <- unique(rbind(errors_Fuels1000, errors_FuelsDuffLitt, errors_FuelsFine, errors_Trees))

errors_all <- rbind(errors_Fuels1000, errors_blank, errors_FuelsDuffLitt, errors_blank, errors_FuelsFine, errors_blank, errors_PostBurn, errors_blank, errors_Trees, errors_blank, errors_Seedlings, errors_blank, errors_HerbsObs)

# errors_CrossProtocol <- unique(rbind(errors_Fuels_slope))
# 
# errors_CrossYear <- unique(rbind())
```

```{r}
# Table of results for quick check
#kable(errors_all, "pipe")

# Create conditional formatting rule
data_temp <- as.data.frame(grepl("PBSev", errors_all$SavedQuery, fixed = TRUE) | grepl(" Post", errors_all$SavedQuery, fixed = TRUE))
colnames(data_temp) <- c("Post")
errors_all_cf <- cbind(errors_all, data_temp) %>% 
  mutate(Post = ifelse(SavedQuery == "", NA, Post))

# Add conditional formating to ouput
errors_all <- condformat(errors_all_cf[1:(nrow(errors_all_cf)), 1:8]) %>%
  rule_fill_discrete(columns = 1:7,
                     expression = (errors_all_cf$Post == "FALSE"),
                     colours = c("TRUE"="#8EA9DB",
                                 "FALSE"="#FFC000"),
                     na.value = "#FFFFFF") %>%
  select(!c("Post"))

# Save as CSV or XLSX 
path_errors
# write.csv(errors_all, paste0(path_errors, "errors_GRCA_RAP.csv"), quote=FALSE, row.names = FALSE, na = "") 
#write_xlsx(errors_all, paste0(path_errors, "errors_GRCA_RAP.xlsx"))
# condformat2excel(errors_all, paste0(path_errors, "errors_GRCA_RAP_formatted.xlsx"), overwrite_wb = TRUE)
condformat2excel(errors_all, paste0(path_errors, "errors_GRCA_RAP_formatted.xlsx"), sheet_name = path_errors_name, overwrite_wb = TRUE)
```
